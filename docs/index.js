!function(t){var r={};function o(e){if(r[e])return r[e].exports;var n=r[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=r,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="",o(o.s="./js/index.js")}({"./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/* require */\n__webpack_require__(/*! mofron */ "./node_modules/mofron/index.js");\n\nvar AppBase = __webpack_require__(/*! mofron-comp-appbase */ "./node_modules/mofron-comp-appbase/index.js");\n\nvar Heading = __webpack_require__(/*! mofron-comp-heading */ "./node_modules/mofron-comp-heading/index.js");\n\nvar DropDown = __webpack_require__(/*! mofron-comp-dropdown */ "./node_modules/mofron-comp-dropdown/index.js");\n\nvar Input = __webpack_require__(/*! mofron-comp-input */ "./node_modules/mofron-comp-input/index.js");\n\nvar Frame = __webpack_require__(/*! mofron-comp-frame */ "./node_modules/mofron-comp-frame/index.js");\n\nvar Button = __webpack_require__(/*! mofron-comp-button */ "./node_modules/mofron-comp-button/index.js");\n\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar Code = __webpack_require__(/*! mofron-comp-code */ "./node_modules/mofron-comp-code/index.js");\n\nvar Footer = __webpack_require__(/*! mofron-comp-footer */ "./node_modules/mofron-comp-footer/index.js");\n\nvar Fade = __webpack_require__(/*! mofron-effect-fade */ "./node_modules/mofron-effect-fade/index.js");\n\nvar HrzPos = __webpack_require__(/*! mofron-effect-hrzpos */ "./node_modules/mofron-effect-hrzpos/index.js");\n\nvar Margin = __webpack_require__(/*! mofron-layout-margin */ "./node_modules/mofron-layout-margin/index.js");\n\nvar Grid = __webpack_require__(/*! mofron-layout-grid */ "./node_modules/mofron-layout-grid/index.js");\n\nvar HrzCent = __webpack_require__(/*! mofron-layout-hrzcenter */ "./node_modules/mofron-layout-hrzcenter/index.js");\n\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\ntry {\n  /* script (extern) */\n\n  /* script (init) */\n  var generate = function generate() {\n    var country = 0 === fm_country.value() ? "" : "country=" + country_prefix[fm_country.value() - 1];\n    var ssid = \'ssid="\' + fm_ssid.value() + \'"\';\n    var pass = \'psk="\' + fm_pass.value() + \'"\';\n    var auth = fm_auth.value();\n    var encry = fm_encry.value();\n    var gen_ret = "";\n    gen_ret += "ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\\n";\n    gen_ret += "update_config=1\\n";\n    gen_ret += country + "\\n";\n    gen_ret += "network={" + "\\n";\n    gen_ret += "\\t" + ssid + "\\n";\n    gen_ret += 0 === auth ? "\\tproto=RSN\\n" : "\\tproto=WPA\\n";\n    gen_ret += "\\tkey_mgmt=WPA-PSK\\n";\n    gen_ret += 0 === encry ? "\\tpairwise=TKIP\\n" : "\\tpairwise=CCMP\\n";\n    gen_ret += 0 === encry ? "\\tgroup=TKIP\\n" : "\\tgroup=CCMP\\n";\n    gen_ret += "\\t" + pass + "\\n";\n    gen_ret += "}\\n";\n    retcode.text(gen_ret);\n  };\n  /* template */\n\n  /* component */\n\n\n  var cmp0_0 = new Heading("wpa_supplicant.conf");\n  var fm_country = new DropDown("Select Country");\n  var fm_ssid = new Input();\n  var fm_pass = new Input();\n  var fm_auth = new DropDown(["WPA2-PSK", "WPA-PSK"]);\n  var fm_encry = new DropDown(["TKIP", "AES"]);\n  var gen_btn = new Button();\n  var cmp0_1_0 = new mofron["class"].Component();\n  var cmp0_1_1_0 = new Text("result:");\n  var retcode = new Code();\n  var result = new Frame();\n  var cmp0_1_1 = new mofron["class"].Component();\n  var cmp0_1 = new mofron["class"].Component();\n  var cmp0_2 = new Footer();\n  var cmp0 = new AppBase();\n  var root_cmp = new mofron["class"].Component();\n  cmp0_1_0.child([fm_country, fm_ssid, fm_pass, fm_auth, fm_encry, gen_btn]);\n  result.child([retcode]);\n  cmp0_1_1.child([cmp0_1_1_0, result]);\n  cmp0_1.child([cmp0_1_0, cmp0_1_1]);\n  cmp0.child([cmp0_0, cmp0_1, cmp0_2]);\n  root_cmp.child([cmp0]);\n  cmp0_0.config({\n    style: {\n      \'padding\': "0.5rem"\n    }\n  });\n  fm_country.config({\n    name: "fm_country",\n    label: "country",\n    height: "0.35rem"\n  });\n  fm_ssid.config({\n    name: "fm_ssid",\n    label: "ssid"\n  });\n  fm_pass.config({\n    name: "fm_pass",\n    type: "password",\n    label: "passphrase"\n  });\n  fm_auth.config({\n    name: "fm_auth",\n    label: "authentication",\n    height: "0.35rem"\n  });\n  fm_encry.config({\n    name: "fm_encry",\n    label: "encryption",\n    height: "0.35rem"\n  });\n  var eff1 = new HrzPos("center");\n  gen_btn.config({\n    name: "gen_btn",\n    clickEvent: generate,\n    effect: eff1,\n    size: new mofron["class"].ConfArg("2.5rem", "0.5rem"),\n    text: "Generate"\n  });\n  var lot2 = new Margin("top", "0.3rem");\n  var lot3 = new Margin("left", "0.7rem");\n  cmp0_1_0.config({\n    layout: [lot2, lot3],\n    theme: {\n      FormItem: {\n        config: {\n          width: "3rem"\n        }\n      }\n    }\n  });\n  cmp0_1_1_0.config({\n    size: "0.3rem"\n  });\n  retcode.config({\n    name: "retcode",\n    style: new mofron["class"].ConfArg({\n      \'font-family\': "monospace"\n    }, {\n      lock: true\n    })\n  });\n  result.config({\n    name: "result",\n    size: new mofron["class"].ConfArg("90%", null)\n  });\n  cmp0_1.config({\n    layout: new Grid([50, 50])\n  });\n  cmp0_2.config({\n    color: \'#ccd1f5\',\n    style: {\n      \'margin-top\': "0.3rem"\n    },\n    height: "0.5rem"\n  });\n  cmp0.config({\n    color: \'#ccd1f5\',\n    baseColor: \'#fafafa\',\n    title: new mofron["class"].ConfArg("CONF-GEN", "./img/icon_b.png")\n  });\n  var eff4 = new Fade(true, 1000);\n  root_cmp.config({\n    effect: eff4,\n    theme: {\n      Text: {\n        config: {\n          color: \'#787878\',\n          font: "\'Major Mono Display\'"\n        }\n      }\n    }\n  });\n  /* script (before) */\n\n  var country_list = ["Andorra", "United Arab Emirates", "Afghanistan", "Antigua & Barbuda", "Anguilla", "Albania", "Armenia", "Angola", "Antarctica", "ArgentinaAS Samoa (American)", "Austria", "Australia", "Aruba", "Åland Islands", "Azerbaijan", "Bosnia & Herzegovina", "Barbados", "Bangladesh", "Belgium", "Burkina Faso", "Bulgaria", "Bahrain", "Burundi", "Benin", "St Barthelemy", "Bermuda", "Brunei", "Bolivia", "Caribbean NL", "Brazil", "Bahamas", "Bhutan", "Bouvet Island", "Botswana", "Belarus", "Belize", "Canada", "Cocos (Keeling) Islands", "Congo (Dem. Rep.)", "Central African Rep.", "Congo (Rep.)", "Switzerland", "Côte d\'Ivoire", "Cook Islands", "Chile", "Cameroon", "China", "Colombia", "Costa Rica", "Cuba", "Cape Verde", "Curaçao", "Christmas Island", "Cyprus", "Czech Republic", "Germany", "Djibouti", "Denmark", "Dominica", "Dominican Republic", "Algeria", "Ecuador", "Estonia", "Egypt", "Western Sahara", "Eritrea", "Spain", "Ethiopia", "Finland", "Fiji", "Falkland Islands", "Micronesia", "Faroe Islands", "France", "Gabon", "Britain (UK)", "Grenada", "Georgia", "French Guiana", "Guernsey", "Ghana", "Gibraltar", "Greenland", "Gambia", "Guinea", "Guadeloupe", "Equatorial Guinea", "Greece", "South Georgia & the South Sandwich Islands", "Guatemala", "Guam", "Guinea-Bissau", "Guyana", "Hong Kong", "Heard Island & McDonald Islands", "Honduras", "Croatia", "Haiti", "Hungary", "Indonesia", "Ireland", "Israel", "Isle of Man", "India", "British Indian Ocean Territory", "Iraq", "Iran", "Iceland", "Italy", "Jersey", "Jamaica", "Jordan", "Japan", "Kenya", "Kyrgyzstan", "Cambodia", "Kiribati", "Comoros", "St Kitts & Nevis", "Korea (North)", "Korea (South)", "Kuwait", "Cayman Islands", "Kazakhstan", "Laos", "Lebanon", "St Lucia", "Liechtenstein", "Sri Lanka", "Liberia", "Lesotho", "Lithuania", "Luxembourg", "Latvia", "Libya", "Morocco", "Monaco", "Moldova", "Montenegro", "St Martin (French)", "Madagascar", "Marshall Islands", "North Macedonia", "Mali", "Myanmar (Burma)", "Mongolia", "Macau", "Northern Mariana Islands", "Martinique", "Mauritania", "Montserrat", "Malta", "Mauritius", "Maldives", "Malawi", "Mexico", "Malaysia", "Mozambique", "Namibia", "New Caledonia", "Niger", "Norfolk Island", "Nigeria", "Nicaragua", "Netherlands", "Norway", "Nepal", "Nauru", "Niue", "New Zealand", "Oman", "Panama", "Peru", "French Polynesia", "Papua New Guinea", "Philippines", "Pakistan", "Poland", "St Pierre & Miquelon", "Pitcairn", "Puerto Rico", "Palestine", "Portugal", "Palau", "Paraguay", "Qatar", "Réunion", "Romania", "Serbia", "Russia", "Rwanda", "Saudi Arabia", "Solomon Islands", "Seychelles", "Sudan", "Sweden", "Singapore", "St Helena", "Slovenia", "Svalbard & Jan Mayen", "Slovakia", "Sierra Leone", "San Marino", "Senegal", "Somalia", "Suriname", "South Sudan", "Sao Tome & Principe", "El Salvador", "St Maarten (Dutch)", "Syria", "Eswatini (Swaziland)", "Turks & Caicos Is", "Chad", "French Southern & Antarctic Lands", "Togo", "Thailand", "Tajikistan", "Tokelau", "East Timor", "Turkmenistan", "Tunisia", "Tonga", "Turkey", "Trinidad & Tobago", "Tuvalu", "Taiwan", "Tanzania", "Ukraine", "Uganda", "US minor outlying islands", "United States", "Uruguay", "Uzbekistan", "Vatican City", "St Vincent", "Venezuela", "Virgin Islands (UK)", "Virgin Islands (US)", "Vietnam", "Vanuatu", "Wallis & Futuna", "Samoa (western)", "Yemen", "Mayotte", "South Africa", "Zambia", "Zimbabwe"],\n      country_prefix = ["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"];\n  fm_country.text(country_list);\n  /* start visible */\n\n  root_cmp.visible(true, function () {\n    try {\n      /* script (after) */\n    } catch (e) {\n      console.error(e.stack);\n    }\n  });\n} catch (e) {\n  console.error(e.stack);\n}\n\n//# sourceURL=webpack:///./js/index.js?')},"./node_modules/babel-loader/lib/index.js!./node_modules/mofron/src/core/namesp.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/mofron/src/core/namesp.js ***!
  \********************************************************************************/
/*! no static exports found */function(module,exports){eval('/**\n * @file namespace.js\n * @author simpart\n */\n//const Window = require("./Window.js");\nmodule.exports = {\n  root: [],\n  window: null,\n  class: {},\n  objkey: {},\n  util: {} //debug  : false\n\n};\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp.js?./node_modules/babel-loader/lib')},"./node_modules/expose-loader/dist/cjs.js?exposes[]=mofron!./node_modules/mofron/src/core/namesp-exposed.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/expose-loader/dist/cjs.js?exposes[]=mofron!./node_modules/mofron/src/core/namesp-exposed.js ***!
  \******************************************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(/*! -!../../../babel-loader/lib?!./namesp.js */ "./node_modules/babel-loader/lib/index.js!./node_modules/mofron/src/core/namesp.js");\nvar ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(/*! ../../../expose-loader/dist/runtime/getGlobalThis.js */ "./node_modules/expose-loader/dist/runtime/getGlobalThis.js");\nvar ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;\nif (typeof ___EXPOSE_LOADER_GLOBAL_THIS___["mofron"] === \'undefined\') ___EXPOSE_LOADER_GLOBAL_THIS___["mofron"] = ___EXPOSE_LOADER_IMPORT___;\nelse throw new Error(\'[exposes-loader] The "mofron" value exists in the global scope, it may not be safe to overwrite it, use the "override" option\')\nmodule.exports = ___EXPOSE_LOADER_IMPORT___;\n\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp-exposed.js?./node_modules/expose-loader/dist/cjs.js?exposes%5B%5D=mofron')},"./node_modules/expose-loader/dist/runtime/getGlobalThis.js":
/*!******************************************************************!*\
  !*** ./node_modules/expose-loader/dist/runtime/getGlobalThis.js ***!
  \******************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(global) { // eslint-disable-next-line func-names\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nmodule.exports = function () {\n  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === \'object\') {\n    return globalThis;\n  }\n\n  var g;\n\n  try {\n    // This works if eval is allowed (see CSP)\n    // eslint-disable-next-line no-new-func\n    g = this || new Function(\'return this\')();\n  } catch (e) {\n    // This works if the window reference is available\n    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === \'object\') {\n      return window;\n    } // This works if the self reference is available\n\n\n    if ((typeof self === "undefined" ? "undefined" : _typeof(self)) === \'object\') {\n      return self;\n    } // This works if the global reference is available\n\n\n    if (typeof global !== \'undefined\') {\n      return global;\n    }\n  }\n\n  return g;\n}();\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./node_modules/expose-loader/dist/runtime/getGlobalThis.js?')},"./node_modules/mofron-comp-appbase/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron-comp-appbase/index.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-appbase/index.js\n * @brief common application component for mofron\n *        it makes easy to build page.\n * @license MIT\n */\nvar Header = __webpack_require__(/*! mofron-comp-appheader */ "./node_modules/mofron-comp-appheader/index.js");\n\nvar Image = __webpack_require__(/*! mofron-comp-image */ "./node_modules/mofron-comp-image/index.js");\n\nvar Synwin = __webpack_require__(/*! mofron-effect-syncwin */ "./node_modules/mofron-effect-syncwin/index.js");\n\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   *\n   * @param (mixed) title parameter\n   *                dict: component config list\n   * @param (component) child component\n   * @short title,child\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("AppBase");\n\n      _this.shortForm("title", "child");\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.header(new Header());\n        this.bgwrap(new mofron["class"].Component());\n        var conts = new mofron["class"].Component({\n          width: \'100%\'\n        });\n        this.child([this.header(), this.bgwrap(), conts]);\n        this.childDom(conts.childDom());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set app title (header text)\n     *\n     * @param (mixed) string/mofron-comp-text: app title\n     * @param (mixed) string: path to app logo image\n     *                mofron-comp-image: logo image\n     * @return (mofron-comp-text) app title\n     * @type parameter\n     */\n\n  }, {\n    key: "title",\n    value: function title(prm, img) {\n      try {\n        var ret = this.header().title(prm);\n\n        if (undefined === prm) {\n          return ret;\n        }\n\n        this.header().image(img);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * app header\n     * \n     * @param (mofron-comp-header) header component\n     * @return (mofron-comp-header) header component\n     * @type parameter\n     */\n\n  }, {\n    key: "header",\n    value: function header(prm) {\n      try {\n        return this.innerComp(\'header\', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * background wrapper\n     *\n     * @param (component) background wrapper component\n     * @return (component) background wrapper component\n     * @type private\n     */\n\n  }, {\n    key: "bgwrap",\n    value: function bgwrap(prm) {\n      try {\n        if (true === comutl.isinc(prm, "Component")) {\n          prm.style({\n            "position": "relative",\n            "z-index": "-10"\n          });\n        }\n\n        return this.innerComp("bgwrap", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * background component\n     * height is synchronized with window height by auto\n     * \n     * @param (component) background component\n     * @return (component) background component\n     * @type parameter\n     */\n\n  }, {\n    key: "background",\n    value: function background(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          var ret = this.bgwrap().child();\n          return 0 === ret.length ? null : ret[0];\n        }\n        /* setter */\n\n\n        this.bgwrap().child(prm);\n        cmputl.rstyle(prm, {\n          \'position\': \'fixed\'\n        });\n        var off = comutl.getsize(this.header().height());\n        off = null !== off ? \'-\' + off.toPixel() + \'px\' : undefined;\n        prm.config({\n          effect: new Synwin({\n            y_offset: off\n          })\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * height\n     * \n     * @param (string (size)) height size\n     * @param (dict) style option\n     * @return (string) height size\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return comutl.sizesum(this.header().height(), _get(_getPrototypeOf(_class.prototype), "height", this).call(this));\n        }\n        /* setter */\n\n\n        var set_hei = comutl.getsize(comutl.sizediff(prm, this.header().height()));\n\n        _get(_getPrototypeOf(_class.prototype), "height", this).call(this, 0 > set_hei.value() ? prm : set_hei, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter header color\n     * \n     * @param (mixed (color)) string: color name, #hex\n     *                        array: [red, green, blue, alpha]\n     * @param (option) style option\n     * @return (string) color\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return this.header().baseColor(prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-appbase/index.js?')},"./node_modules/mofron-comp-appheader/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-comp-appheader/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n *  @file  mofron-comp-appheader/index.js\n *  @brief app header component for mofron\n *  @license MIT\n */\nvar Image = __webpack_require__(/*! mofron-comp-image */ "./node_modules/mofron-comp-image/index.js");\n\nvar Header = __webpack_require__(/*! mofron-comp-txtheader */ "./node_modules/mofron-comp-txtheader/index.js");\n\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar Link = __webpack_require__(/*! mofron-event-link */ "./node_modules/mofron-event-link/index.js");\n\nvar Synhei = __webpack_require__(/*! mofron-effect-synchei */ "./node_modules/mofron-effect-synchei/index.js");\n\nvar Hrzpos = __webpack_require__(/*! mofron-effect-hrzpos */ "./node_modules/mofron-effect-hrzpos/index.js");\n\nvar Horiz = __webpack_require__(/*! mofron-layout-horizon */ "./node_modules/mofron-layout-horizon/index.js");\n\nvar comutl = mofron.util.common;\nvar ConfArg = mofron["class"].ConfArg;\n\nmodule.exports = /*#__PURE__*/function (_Header) {\n  _inherits(_class, _Header);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (mixed) mixed: title config parameter\n   *                dict: component config list\n   * @param (mixed) image config parameter\n   * @param (component) navi config parameter \n   * @short title,image,navi\n   * @type private\n   */\n  function _class(p1, p2, p3) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'AppHeader\');\n\n      _this.shortForm(\'title\', \'image\', \'navi\');\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2, p3);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * init dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.child(this.image(), 0);\n        this.image().event(new Link("./"));\n        this.text().event(new Link("./"));\n        var conts = new mofron["class"].Component({\n          layout: new Horiz()\n        });\n        this.child([conts, this.naviWrap()]);\n        this.styleDom(this.styleDom());\n        this.childDom(conts.childDom());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * header title\n     *\n     * @param (mixed) string: header title\n     *                mofron-comp-text: replace title component of header\n     * @param (key-value) text config\n     * @return (mofron-comp-text) text contents\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(txt, cnf) {\n      try {\n        var ret = _get(_getPrototypeOf(_class.prototype), "text", this).call(this, txt, cnf);\n\n        if (undefined !== txt) {\n          this.text().style({\n            "margin-left": "0.2rem"\n          }, {\n            passive: true\n          });\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * header title, same as text\n     * \n     * @param (mixed) string: header title\n     *                mofron-comp-text: replace title component of header\n     * @param (key-value) text config\n     * @return (mofron-comp-text) text contents\n     * @type parameter\n     */\n\n  }, {\n    key: "title",\n    value: function title(txt, cnf) {\n      try {\n        return this.text(txt, cnf);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter logo image\n     * insert logo image to left side of title\n     *\n     * @param (mixed) string: path to logo image\n     *                mofron-comp-image: replace image component\n     * @param (key-value) image config\n     * @return (mofron-comp-image) logo image\n     * @type parameter\n     */\n\n  }, {\n    key: "image",\n    value: function image(prm, cnf) {\n      try {\n        if (undefined !== cnf) {\n          var add_cnf = true === comutl.isinc(prm, \'Image\') ? prm : this.image();\n          add_cnf.config(cnf);\n        }\n\n        if (\'string\' === typeof prm) {\n          this.image().config({\n            path: prm\n          });\n          return;\n        } else if (true === comutl.isinc(prm, \'Image\')) {\n          prm.config({\n            effect: new Synhei(this)\n          });\n          prm.style({\n            "margin-left": "0.1rem"\n          }, {\n            passive: true\n          });\n        }\n\n        return this.innerComp(\'image\', prm, Image);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter navigate area\n     *\n     * @param (component) navigate component\n     * @return (array) navigate component list\n     * @type parameter\n     */\n\n  }, {\n    key: "navi",\n    value: function navi(prm) {\n      try {\n        return this.naviWrap().child(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * logo image position and size offset\n     * \n     * @param (string (size)) left offset position\n     * @param (string (size)) height offset position\n     * \n     */\n\n  }, {\n    key: "imgpos",\n    value: function imgpos(lft, hei) {\n      try {\n        this.image().style({\n          "margin-left": lft\n        });\n        var syn = this.image().effect({\n          name: "SyncHei"\n        });\n\n        if (true === comutl.isinc(syn, "SyncHei")) {\n          syn.offset(hei);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter url jump target\n     * it jump to this url when user clicks logo or title\n     * set null if you don\'t want jump\n     * \n     * @param (mixed) string: jump url\n     *                null: not jump\n     * @return (string) jump url\n     * @type parameter\n     */\n\n  }, {\n    key: "url",\n    value: function url(prm) {\n      try {\n        var txt_link = this.text().event({\n          name: "Link"\n        });\n        var img_link = this.image().event({\n          name: "Link"\n        });\n\n        if (undefined === prm) {\n          return "" === txt_link.url() ? null : txt_link.url();\n        }\n\n        if (null === prm) {\n          txt_link.config({\n            url: "",\n            suspend: true\n          });\n          img_link.config({\n            url: "",\n            suspend: true\n          });\n        } else {\n          txt_link.url(prm);\n          img_link.url(prm);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter navigate wrapper\n     * \n     * @param (component) wrap component\n     * @return (component) wrap component\n     * @type private\n     */\n\n  }, {\n    key: "naviWrap",\n    value: function naviWrap(prm) {\n      try {\n        if (true === comutl.isinc(prm, \'Component\')) {\n          prm.config({\n            layout: new Horiz(),\n            effect: new Hrzpos("right", "0.2rem")\n          });\n        }\n\n        return this.innerComp(\'naviWrap\', prm, mofron["class"].Component);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Header);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-appheader/index.js?')},"./node_modules/mofron-comp-button/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-comp-button/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  mofron-comp-button/index.js\n * @brief button component for mofron\n * @license MIT\n */\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar Click = __webpack_require__(/*! mofron-event-click */ "./node_modules/mofron-event-click/index.js");\n\nvar SynHei = __webpack_require__(/*! mofron-effect-synchei */ "./node_modules/mofron-effect-synchei/index.js");\n\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * constructor\n   * \n   * @param (mixed) string: text parameter\n   *                object: component config\n   * @param (mixed) clickEvent parameter\n   * @short text,clickEvent\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Button\');\n\n      _this.shortForm(\'text\', \'clickEvent\');\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this, \'button\');\n        /* set button text */\n\n\n        this.child(this.text());\n        /* set default config */\n\n        this.height(\'0.25rem\');\n        this.status(true);\n        this.text().effect(new SynHei(this)); //,\'-0.05rem\'));\n\n        this.style({\n          \'border-width\': \'0.01rem\'\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * button text contents\n     * \n     * @param (mixed) string: button text contents\n     *                mofron-comp-text: button text component\n     * @param (mixed) text component config\n     * @return (mofron-comp-text) button text\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(txt, cnf) {\n      try {\n        if (\'string\' === typeof txt) {\n          this.text().text(txt);\n          return;\n        }\n\n        if (undefined !== cnf) {\n          this.text().config(cnf);\n        }\n\n        return this.innerComp(\'text\', txt, Text);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * button click event\n     *\n     * @param (function) click event function\n     * @param (mixed) function parameter\n     * @type parameter\n     */\n\n  }, {\n    key: "clickEvent",\n    value: function clickEvent(func, prm) {\n      try {\n        var ev = this.event({\n          modname: "Click",\n          tag: arguments.callee.name\n        });\n\n        if (null === ev) {\n          ev = new Click({\n            tag: arguments.callee.name\n          });\n          this.event(ev);\n        }\n\n        ev.listener(func, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * button text color\n     * \n     * @param (mixed (color)) string: button text color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @param (key-value) style option\n     * @return (mixed) button text color\n     *                 null: not set yet\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(clr, opt) {\n      try {\n        return this.text().mainColor(clr, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * button border color\n     * \n     * @param (mixed (color)) string: button border color, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @param (key-value) style option\n     * @return (mixed) button border color\n     *                 null; not set yet\n     * @type parameter\n     */\n\n  }, {\n    key: "accentColor",\n    value: function accentColor(clr, opt) {\n      try {\n        if (undefined !== clr) {\n          this.style({\n            \'border-style\': null === clr ? \'none\' : \'solid\'\n          }, opt);\n        }\n\n        return cmputl.color(this, \'border-color\', clr, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * change disable mode\n     * change this button to grayout and it will be can not click.\n     *\n     * @type function\n     */\n\n  }, {\n    key: "disabled",\n    value: function disabled() {\n      try {\n        this.status(false);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * change enable mode\n     *\n     * @type function\n     */\n\n  }, {\n    key: "enabled",\n    value: function enabled() {\n      try {\n        this.status(true);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * button status\n     *\n     * @param (boolean) change enable/disable mode\n     * @return (boolean) current status\n     * @type parameter\n     */\n\n  }, {\n    key: "status",\n    value: function status(sts) {\n      try {\n        if (undefined === sts) {\n          /* getter */\n          return \'disabled\' === this.childDom().attrs(\'disabled\') ? false : true;\n        }\n        /* setter */\n\n\n        if (\'boolean\' !== typeof sts) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.childDom().attrs({\n          \'disabled\': true === sts ? null : \'disabled\'\n        });\n        this.childDom().style({\n          \'cursor\': true === sts ? \'pointer\' : \'not-allowed\'\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-button/index.js?')},"./node_modules/mofron-comp-code/index.js":
/*!************************************************!*\
  !*** ./node_modules/mofron-comp-code/index.js ***!
  \************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-{@comp-name}/index.js\n * @brief component module template for developper\n * @license MIT\n */\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nmodule.exports = /*#__PURE__*/function (_Text) {\n  _inherits(_class, _Text);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (mixed) text parameter\n   *                key-value: component config\n   * @short text\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Code");\n      /* init config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        this.rootDom(new mofron["class"].Dom("pre", this));\n        this.style({\n          "overflow": "scroll"\n        });\n        var code = new mofron["class"].Dom("code", this);\n        this.childDom().child(code);\n        this.childDom(code);\n        this.size("0.16rem");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Text);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-code/index.js?')},"./node_modules/mofron-comp-dropdown/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-comp-dropdown/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   mofron-comp-dropdown/index.js\n * @brief  dropdown component for mofron\n * @license MIT\n */\nvar FormItem = __webpack_require__(/*! mofron-comp-formitem */ "./node_modules/mofron-comp-formitem/index.js");\n\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar onCommon = __webpack_require__(/*! mofron-event-oncommon */ "./node_modules/mofron-event-oncommon/index.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_FormItem) {\n  _inherits(_class, _FormItem);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize dropdown component\n   * \n   * @param (mixed) \'text\' parameter\n   *                key-value: component config\n   * @short text\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("DropDown");\n\n      _this.shortForm("text");\n      /* init config */\n\n\n      _this.confmng().add("select", {\n        type: "number",\n        init: 0\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        var sel = new mofron["class"].Dom("select", this);\n        this.childDom().child(sel);\n        this.childDom(sel);\n        var rdom = this.rootDom()[0];\n        sel.style().listener("width", function (w1, w2, w3) {\n          rdom.style({\n            "width": w2[0]\n          });\n        });\n        /* init change event */\n\n        var cevt = function cevt(p1, p2, p3) {\n          try {\n            var chg_evt = p1.changeEvent();\n\n            for (var cidx in chg_evt) {\n              chg_evt[cidx].exec(p1, p1.select());\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        this.event(new onCommon(cevt, "onchange"));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set select index\n     *\n     * @type private \n     */\n\n  }, {\n    key: "afterRender",\n    value: function afterRender() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "afterRender", this).call(this);\n\n        this.select(null === this.select() ? 0 : this.confmng("select"));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * select text list setter/getter\n     *\n     * @param (mixed) string:  select text contents\n     *                array: select text contents list\n     *                undefined: call as getter\n     * @return (array) select text contents [string,..]\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(prm, cnf) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return this.child();\n        }\n        /* setter */\n\n\n        if (true === Array.isArray(prm)) {\n          for (var pidx in prm) {\n            this.text(prm[pidx], cnf);\n          }\n\n          return;\n        }\n\n        var buf = this.childDom();\n        var odom = new mofron["class"].Dom("option", this);\n        this.childDom().child(odom);\n        this.childDom(odom);\n\n        if ("string" === typeof prm) {\n          prm = new Text(prm);\n        }\n\n        if (undefined !== cnf) {\n          prm.config(cnf);\n        }\n\n        this.child(prm);\n        this.childDom(buf);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * select index setter/getter\n     *\n     * @param (number) selected index\n     *                 undefined: call as getter\n     * @return (mixed) number: selected index\n     *                 null: not selected\n     * @type parameter\n     */\n\n  }, {\n    key: "select",\n    value: function select(prm) {\n      try {\n        var opts = this.childDom().child();\n\n        if (undefined === prm) {\n          /* getter */\n          if (false === this.isExists()) {\n            return this.confmng("select");\n          } else {\n            for (var oidx in opts) {\n              if (true === opts[oidx].props("selected")) {\n                return parseInt(oidx);\n              }\n            }\n          }\n\n          return null;\n        }\n        /* setter */\n\n\n        if (false === this.isExists()) {\n          this.confmng("select", prm);\n        } else {\n          if (undefined === opts[prm]) {\n            throw new Error("invalid parameter");\n          }\n\n          opts[prm].props({\n            "selected": true\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * item value\n     *\n     * @param (number) the same as select parameter\n     * @return (mixed) the same as select parameter\n     * @type parameter\n     */\n\n  }, {\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.select(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * clear item value\n     *\n     * @type function\n     */\n\n  }, {\n    key: "clear",\n    value: function clear() {\n      try {\n        this.select(0);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(FormItem);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-dropdown/index.js?')},"./node_modules/mofron-comp-footer/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-comp-footer/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   mofron-comp-footer/index.js\n * @brief  footer component for mofron\n * @license MIT\n */\nvar Border = __webpack_require__(/*! mofron-effect-border */ "./node_modules/mofron-effect-border/index.js");\n\nvar Vrtpos = __webpack_require__(/*! mofron-effect-vrtpos */ "./node_modules/mofron-effect-vrtpos/index.js");\n\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (dict) component config\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Footer\');\n\n      _this.config(p1);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.size(\'100%\', \'2rem\');\n        this.effect(new Border({\n          position: \'top\',\n          color: [211, 211, 211],\n          tag: "Footer"\n        }));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * background color setter/getter\n     * \n     * @param (mixed) (mixed (color)) string: color name, #hex\n     *                array: [red, green, blue, (alpha)]\n     * @param (dict) style option\n     * @return (mixed) string: text color\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return this.baseColor(prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border color setter/getter\n     * \n     * @param (mixed) (mixed (color)) string: color name, #hex\n     *                array: [red, green, blue, (alpha)]\n     * @param (dict) style option\n     * @return (mixed) string: text color\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "accentColor",\n    value: function accentColor(prm, opt) {\n      try {\n        if (undefined !== prm) {\n          this.effect({\n            name: "Border",\n            tag: "Footer"\n          }).color(prm);\n        }\n\n        return cmputl.color(this, "border-top", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-footer/index.js?')},"./node_modules/mofron-comp-formitem/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-comp-formitem/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   mofron-comp-formitem/index.js\n * @brief  base component for form item.\n *         this component has some function for form item.\n *         extending this class makes it easier to develop form item components.\n * @attention it needs to overwrite at extending class since some functions is an interface.\n * @license MIT\n */\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar onCommon = __webpack_require__(/*! mofron-event-oncommon */ "./node_modules/mofron-event-oncommon/index.js");\n\nvar comutl = mofron.util.common;\nvar ConfArg = mofron["class"].ConfArg;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: component config\n   * @short label\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'FormItem\');\n\n      _this.shortForm(\'label\');\n      /* init config */\n\n\n      _this.confmng().add(\'required\', {\n        type: \'boolean\',\n        init: false\n      });\n\n      _this.confmng().add("focusEvent", {\n        type: \'event\',\n        list: true\n      });\n\n      _this.confmng().add(\'changeEvent\', {\n        type: \'event\',\n        list: true\n      });\n\n      _this.confmng().add(\'sendKey\', {\n        type: \'string\'\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n        /* label */\n\n\n        this.child(this.label());\n        /* set focus event */\n\n        var itm = this;\n        this.event([new onCommon(function () {\n          var evt = itm.focusEvent();\n\n          for (var eidx in evt) {\n            evt[eidx][0](itm, true, evt[eidx][1]);\n          }\n        }, "onfocus"), new onCommon(function () {\n          var evt = itm.focusEvent();\n\n          for (var eidx in evt) {\n            evt[eidx][0](itm, false, evt[eidx][1]);\n          }\n        }, "onblur")]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set focus status\n     *\n     * @type private\n     */\n\n  }, {\n    key: "afterRender",\n    value: function afterRender() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "afterRender", this).call(this);\n\n        this.focus(this.focus());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * form item label setter/getter\n     *\n     * @param (mixed) string: label text\n     *                mofron-comp-text: text component for label\n     *                undefined: call as getter\n     * @return (mofron-comp-text) text component for label\n     * @type parameter\n     */\n\n  }, {\n    key: "label",\n    value: function label(prm) {\n      try {\n        if (true === comutl.isinc(prm, \'Text\')) {\n          prm.config({\n            text: \'\',\n            visible: false,\n            style: {\n              \'margin-right\': \'0.05rem\'\n            }\n          });\n        } else if (\'string\' === typeof prm) {\n          this.label().config({\n            text: prm,\n            style: {\n              \'display\': null\n            }\n          });\n          return;\n        }\n\n        return this.innerComp(\'label\', prm, Text);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * horizontal config setter/getter\n     * \n     * @param (boolean) true: horizontal placing (form item is placed next to a label)\n     *                  false: normal placing (form item is placed under a label)\n     *                  undefined: call as getter\n     * @return (boolean) placing config\n     * @type parameter\n     */\n\n  }, {\n    key: "horizon",\n    value: function horizon(prm) {\n      try {\n        if (undefined === prm) {\n          return \'flex\' === this.rootDom()[0].style(\'display\') ? true : false;\n        }\n        /* setter */\n\n\n        this.rootDom()[0].style({\n          \'display\': true === prm ? \'flex\' : null\n        }, true);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * config for required flag setter/getter\n     * it become required item in form if this flag is true\n     * \n     * @param (boolean) true: required item (An error is detected if data is sent when empty this item data)\n     *                  false: not required item\n     *                  undefined: call as getter\n     * @return (boolean) required flag\n     * @type parameter\n     */\n\n  }, {\n    key: "required",\n    value: function required(flg) {\n      try {\n        return this.confmng(\'required\', flg);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * item value\n     * interface for getter/setter of formitem\n     * \n     * @param (mixed) item value\n     * @return (mixed) item value\n     * @type private\n     */\n\n  }, {\n    key: "value",\n    value: function value(prm) {\n      console.warn(\'not implements\');\n    }\n    /**\n     * check item value about valid or invalid\n     * \n     * @return (mixed) string: error reason\n     *                 null: no error\n     * @type private\n     */\n\n  }, {\n    key: "checkValue",\n    value: function checkValue() {\n      try {\n        if (true === this.required()) {\n          if (null === this.value()) {\n            return \'\' === this.label().text() ? \'empty value\' : this.label().text() + \' is required\';\n          }\n        }\n\n        return null;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * focus status setter/getter\n     * \n     * @param (boolean) true: focus this item\n     *                  false: defocus this item\n     *                  undefined: call as getter\n     * @return (boolean) focus status\n     * @type parameter\n     */\n\n  }, {\n    key: "focus",\n    value: function focus(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return document.activeElement === this.childDom().id() ? true : false;\n        }\n        /* setter */\n\n\n        if (true === this.isExists()) {\n          if (true === prm) {\n            this.childDom().getRawDom().focus();\n          } else {\n            this.childDom().getRawDom().blur();\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * focus event function setter/getter\n     * \n     * @param (function) event function\n     *                   undefined: call as getter\n     * @param (mixed) function parameter\n     * @return (array) event list\n     * @type parameter\n     */\n\n  }, {\n    key: "focusEvent",\n    value: function focusEvent(fnc, prm) {\n      try {\n        return this.confmng("focusEvent", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * change event function setter/getter\n     *\n     * @param (function) change event\n     *                   undefined: call as getter\n     * @param (mix) event parameter\n     * @return (array) event list\n     * @type private\n     */\n\n  }, {\n    key: "changeEvent",\n    value: function changeEvent(fnc, prm) {\n      try {\n        return this.confmng(\'changeEvent\', fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * item status setter/getter\n     * \n     * @param (boolean) true: change enable mode [default]\n     *                  false: change disable mode\n     *                  undefined: call as getter\n     * @return (boolean) current item status\n     * @type parameter\n     */\n\n  }, {\n    key: "status",\n    value: function status(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return \'disabled\' === this.childDom().attrs(\'disabled\') ? true : false;\n        }\n        /* setter */\n\n\n        this.childDom().attrs({\n          \'disabled\': true === prm ? \'disabled\' : null\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * enable form item\n     * \n     * @type function\n     */\n\n  }, {\n    key: "enabled",\n    value: function enabled() {\n      try {\n        return this.status(true);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * disable form item\n     *\n     * @type function\n     */\n\n  }, {\n    key: "disabled",\n    value: function disabled() {\n      try {\n        return this.status(false);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * a key of POST data setter/getter\n     * \n     * @param (string) send key\n     *                 undefined: call as getter\n     * @return (string) send key\n     * @type parameter\n     */\n\n  }, {\n    key: "sendKey",\n    value: function sendKey(prm) {\n      try {\n        return this.confmng(\'sendKey\', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * clear item value\n     *\n     * @type private\n     */\n\n  }, {\n    key: "clear",\n    value: function clear() {\n      console.warn(\'not implements\');\n    }\n    /**\n     * item height setter/getter\n     * \n     * @param (string (size)) item height (if horizon function is false and visible function is true, height will be bisected.)\n     *                        undefined: call as getter\n     * @param (key-value) style option\n     * @return (mixed) string(size): item height\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          if (false === this.horizon() && (true === this.label().visible() || false === this.childDom().isPushed() && "none" !== this.label().style("display"))) {\n            return comutl.sizesum(this.label().height(), _get(_getPrototypeOf(_class.prototype), "height", this).call(this));\n          }\n\n          return _get(_getPrototypeOf(_class.prototype), "height", this).call(this);\n        }\n        /* setter */\n\n\n        var set_siz = comutl.getsize(prm);\n\n        if (null == set_siz) {\n          return;\n        }\n\n        if (false === this.horizon() && true === this.label().visible()) {\n          _get(_getPrototypeOf(_class.prototype), "height", this).call(this, comutl.roundup(set_siz.value() / 2) + set_siz.type(), opt);\n        } else {\n          _get(_getPrototypeOf(_class.prototype), "height", this).call(this, set_siz, opt);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-formitem/index.js?')},"./node_modules/mofron-comp-frame/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-comp-frame/index.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   mofron-comp-frame/index.js\n * @brief  frame component for mofron\n * @feature default size is 1rem × 1rem\n *          frame size is includes border size\n * @license MIT\n */\nvar Radius = __webpack_require__(/*! mofron-effect-radius */ "./node_modules/mofron-effect-radius/index.js");\n\nvar Shadow = __webpack_require__(/*! mofron-effect-shadow */ "./node_modules/mofron-effect-shadow/index.js");\n\nvar Border = __webpack_require__(/*! mofron-effect-border */ "./node_modules/mofron-effect-border/index.js");\n\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize frame component\n   * \n   * @param (mixed) width parameter\n   *                key-value: component option\n   * @param (string (size)) height parameter\n   * @short width,height\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("Frame");\n\n      _this.shortForm("width", "height");\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n        /* configure border style */\n\n\n        this.effect([new Border({\n          color: [190, 190, 190],\n          tag: "Frame"\n        }), new Radius("0rem"), new Shadow("0rem")]);\n        this.childDom().style().listener("border-width", function (p1, p2, p3) {\n          try {\n            var o_bdr = comutl.sizesum(p2["border-width"], p2["border-width"]);\n            p3.size(comutl.sizesum(cmputl.size(p3, "width"), o_bdr), comutl.sizesum(cmputl.size(p3, "height"), o_bdr));\n          } catch (e) {}\n        }, this);\n        this.size("1rem", "1rem");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * background color\n     * \n     * @param (mixed (color)) string: background color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @param (key-value) style option\n     * @return (string) background color\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return cmputl.color(this, "background", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border color\n     * \n     * @param (mixed (color)) string: border color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @return (mixed (color)) border color\n     * @type parameter\n     */\n\n  }, {\n    key: "accentColor",\n    value: function accentColor(prm, opt) {\n      try {\n        this.effect({\n          modname: "Shadow"\n        }).color(prm);\n        return this.effect({\n          modname: "Border"\n        }).color(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * radius effect\n     *\n     * @param (string (size)) radius effect value\n     * @return (string (size)) radius effect value\n     * @type parameter\n     */\n\n  }, {\n    key: "radius",\n    value: function radius(prm) {\n      try {\n        return this.effect({\n          modname: "Radius"\n        }).value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * shadow effect\n     *\n     * @param (string (size)) shadow value\n     * @return (string (size)) shadow value\n     * @type parameter\n     */\n\n  }, {\n    key: "shadow",\n    value: function shadow(prm) {\n      try {\n        return this.effect({\n          modname: "Shadow"\n        }).value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border width setter\n     * \n     * @param (string(size)) top border width\n     * @param (string(size)) right border width\n     * @param (string(size)) bottom border width\n     * @param (string(size)) left border width\n     * @type parameter\n     */\n\n  }, {\n    key: "borderWidth",\n    value: function borderWidth(top, right, bottom, left) {\n      try {\n        this.style({\n          "border-width": null\n        }, {\n          lock: true\n        });\n        this.style({\n          "border-top-width": top,\n          "border-right-width": right,\n          "border-bottom-width": bottom,\n          "border-left-width": left\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * frame width\n     * \n     * @param (string (size)) frame width\n     * @param (key-value) style option\n     * @return (string (size)) frame width\n     * @type parameter\n     */\n\n  }, {\n    key: "width",\n    value: function width(prm, opt) {\n      try {\n        return this.frmsiz("width", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * frame height\n     * \n     * @param (string (size)) frame height\n     * @param (key-value) style option\n     * @return (string (size)) frame height\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        return this.frmsiz("height", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set frame size\n     * \n     * @param (string) size target (width,height)\n     * @type private\n     */\n\n  }, {\n    key: "frmsiz",\n    value: function frmsiz(tgt, val, opt) {\n      try {\n        if ("width" !== tgt && "height" !== tgt) {\n          throw new Error("invalid parameter");\n        }\n\n        var bdr_siz = this.effect({\n          name: "Border",\n          tag: "Frame"\n        }).width();\n        bdr_siz = comutl.sizesum(bdr_siz, bdr_siz);\n\n        if (undefined === val) {\n          /* getter */\n          return comutl.sizesum(_get(_getPrototypeOf(_class.prototype), tgt, this).call(this), bdr_siz);\n        }\n        /* setter */\n\n\n        _get(_getPrototypeOf(_class.prototype), tgt, this).call(this, comutl.sizesum(val, null === bdr_siz ? null : "-" + bdr_siz));\n      } catch (e) {\n        return _get(_getPrototypeOf(_class.prototype), tgt, this).call(this, val);\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-frame/index.js?')},"./node_modules/mofron-comp-header/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-comp-header/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   mofron-comp-header/index.js\n * @brief  header component for mofron\n *         This component for placing at the top of the page etc. and displaying the site title etc.\n * @feature A header\'s child components are placed horizontally since header has a horizon layout.\n * @attention it maybe needs a \'false\' config at bind parameter that used as a child component.\n * @license MIT\n */\nvar Horizon = __webpack_require__(/*! mofron-layout-horizon */ "./node_modules/mofron-layout-horizon/index.js");\n\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * constructor\n   * \n   * @param (mixed) child parameter\n   *                key-value: component config\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n      /* init config */\n\n      _this.modname("Header");\n\n      _this.confmng().add("wrap", {\n        type: "Dom"\n      });\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        var wrap = new mofron["class"].Component();\n        this.child(wrap);\n        this.childDom(wrap.childDom());\n        this.layout(new Horizon());\n        /* border config */\n\n        this.style({\n          "border-bottom-style": "solid",\n          "border-bottom-width": "0.01rem"\n        });\n        this.size("100%", "0.5rem");\n        this.bind(true);\n        this.mainColor([211, 211, 211]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * header height\n     * \n     * @param (string (size)) header height (default is "0.5rem")\n     * @param (option) style option\n     * @return (string (size)) header height\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(val, opt) {\n      try {\n        if (undefined === val) {\n          return this.rootDom()[0].style("height");\n        }\n\n        this.rootDom()[0].style({\n          height: val\n        }, opt);\n        this.getTree().getChild()[0].height(val, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * binding header \n     * \n     * @param (boolean) true: header position is fixed. display header even if user scrolls. (default)\n     *                  false: header position is not fixed.\n     * @return (boolean) binding config\n     * @type parameter\n     */\n\n  }, {\n    key: "bind",\n    value: function bind(flg) {\n      try {\n        if (undefined === flg) {\n          /* getter */\n          return \'fixed\' === this.style(\'position\') ? true : false;\n        }\n        /* setter */\n\n\n        if (\'boolean\' !== typeof flg) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        if (true === flg) {\n          this.style({\n            \'position\': \'fixed\',\n            \'z-index\': 999\n          });\n        } else {\n          this.style({\n            position: null\n          }, \'fixed\' === this.style(\'position\') ? false : true);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border bottom color\n     *\n     * @param (mixed (color)) string: border bottom color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @param (key-value) stye option\n     * @return (string) border bottom color\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return cmputl.color(this, "border-bottom-color", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-header/index.js?')},"./node_modules/mofron-comp-heading/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron-comp-heading/index.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-heading/index.js\n * @brief heading component for mofron\n * @license MIT\n */\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar Horiz = __webpack_require__(/*! mofron-layout-horizon */ "./node_modules/mofron-layout-horizon/index.js");\n\nvar VrtPos = __webpack_require__(/*! mofron-effect-vrtpos */ "./node_modules/mofron-effect-vrtpos/index.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (mixed) text parameter\n   *                key-value: component config\n   * @param level parameter\n   * @short text,level\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Heading\');\n\n      _this.shortForm(\'text\', \'level\');\n      /* init config */\n\n\n      _this.confmng().add(\'level\', {\n        type: \'number\',\n        init: 1,\n        select: [1, 2, 3, 4, 5, 6]\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.layout(new Horiz());\n        this.child(this.text());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * heading text contents\n     * \n     * @param (mixed) string: heading text contents\n     *                mofron-comp-text: heading text component\n     * @return (mofron-comp-text) heading text component\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(prm) {\n      try {\n        if (true === comutl.isinc(prm, "Text")) {\n          prm.effect(new VrtPos("center"));\n          prm.style({\n            "margin-left": "0.2rem"\n          });\n          this.innerComp(\'text\', prm);\n          this.resize();\n          return;\n        } else if ("string" === typeof prm) {\n          this.text().text(prm);\n          return;\n        }\n\n        return this.innerComp(\'text\', prm, Text);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text size\n     * \n     * @param (number) text size level [1-6]\n     * @return (number) text size level\n     * @type parameter\n     */\n\n  }, {\n    key: "level",\n    value: function level(prm) {\n      try {\n        var ret = this.confmng(\'level\', prm);\n\n        if (undefined !== prm) {\n          this.resize();\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * resize text\n     * \n     * @type private\n     */\n\n  }, {\n    key: "resize",\n    value: function resize() {\n      try {\n        var siz = [\'0.32rem\', \'0.24rem\', \'0.18rem\', \'0.16rem\', \'0.12rem\', \'0.10rem\'];\n        this.text().size(siz[this.level() - 1]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text color\n     * \n     * @param (mixed (color)) string: text color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @param (key-value) style option\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return this.text().color(prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-heading/index.js?')},"./node_modules/mofron-comp-image/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-comp-image/index.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-image/index.js\n * @brief image component for mofron\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize image component\n   *\n   * @param (mixed) path parameter\n   *                key-value: component option\n   * @short path\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("Image");\n\n      _this.shortForm("path");\n\n      if (0 < arguments.length) {\n        _this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   *\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this, \'img\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * image path\n     *\n     * @param (string) path to image\n     * @return (string) path to image\n     * @type parameter\n     */\n\n  }, {\n    key: "path",\n    value: function path(prm) {\n      try {\n        return this.value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * base64 image value\n     *\n     * @param (number) base64 image value\n     * @return (number) base64 image value\n     * @type parameter\n     */\n\n  }, {\n    key: "base64",\n    value: function base64(prm) {\n      try {\n        return this.value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * src value of dom attribute\n     * \n     * @param (string) path to image file\n     * @return (string) path to image file\n     * @type parameter\n     */\n\n  }, {\n    key: "src",\n    value: function src(prm) {\n      try {\n        return this.value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * src value of dom attribute\n     * \n     * @param (mixed) string: path to image\n     *                number: base64 value\n     * @return (mixed) src value of dom attribute\n     * @type private\n     */\n\n  }, {\n    key: "value",\n    value: function value(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return this.target().attr(\'src\');\n        }\n        /* setter */\n\n\n        if (\'string\' !== typeof prm && \'number\' !== typeof prm) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.childDom().attrs({\n          src: prm\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-image/index.js?')},"./node_modules/mofron-comp-input/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-comp-input/index.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-input/index.js\n * @brief input component for mofron\n *        This is component for form items.\n * @feature input text size is automatically changed when the height is changed.\n * @license MIT\n */\nvar FormItem = __webpack_require__(/*! mofron-comp-formitem */ "./node_modules/mofron-comp-formitem/index.js");\n\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_FormItem) {\n  _inherits(_class, _FormItem);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * constructor\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: component config\n   * @short text\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("Input");\n\n      _this.shortForm("text");\n      /* init config */\n\n\n      _this.confmng().add("sizeOffset", {\n        type: "size",\n        init: "0.06rem"\n      });\n\n      _this.confmng().add("txtbuf", {\n        type: "string"\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   *\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      var _this2 = this;\n\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n        /* init input contents */\n\n\n        var inp = new mofron["class"].Dom({\n          tag: "input",\n          component: this,\n          attrs: {\n            type: "text"\n          }\n        });\n        this.childDom().child(inp);\n        this.childDom(inp);\n        this.styleDom(inp);\n        this.focusEvent(function (p1, p2) {\n          try {\n            var txt = p1.text();\n\n            if (true === p2) {\n              _this2.confmng("txtbuf", null === txt ? "" : txt);\n            } else if (txt !== _this2.confmng("txtbuf")) {\n              var cevt = p1.changeEvent();\n\n              for (var cidx in cevt) {\n                cevt[cidx][0](p1, txt, cevt[cidx][1]);\n              }\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        });\n        this.rootDom()[0].style({\n          \'align-items\': \'center\'\n        });\n        /* set default size */\n\n        this.size("1.5rem", "0.25rem");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "beforeRender",\n    value: function beforeRender() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "beforeRender", this).call(this);\n\n        if (true === this.horizon()) {\n          this.label().size(this.height());\n        }\n      } catch (e) {}\n    }\n    /**\n     * input text setter/getter\n     *\n     * @param (string) input text\n     *                 undefined: call as getter\n     * @return (string) input text\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return this.childDom().props("value");\n        }\n        /* setter */\n\n\n        if ("string" !== typeof prm) {\n          throw new Error("invalid parameter");\n        }\n\n        this.childDom().props({\n          value: prm\n        });\n        var chg_evt = this.changeEvent();\n\n        for (var cidx in chg_evt) {\n          chg_evt[cidx][0](this, prm, chg_evt[cidx][1]);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set font family\n     *\n     * @param (string) primary font name\n     *                 undefined: call as getter\n     * @param (string) secondary font name\n     * @return (array) font name [primary, secondary]\n     * @type parameter\n     */\n\n  }, {\n    key: "font",\n    value: function font() {\n      try {\n        if (0 === arguments.length) {\n          /* getter */\n          return this.style("font-family");\n        }\n        /* setter */\n\n\n        var set_fnt = "";\n\n        for (var aidx = 0; aidx < arguments.length; aidx++) {\n          if ("string" !== typeof arguments[aidx]) {\n            throw new Error("invalid parameter");\n          }\n\n          set_fnt += arguments[aidx] + ",";\n        }\n\n        set_fnt = set_fnt.substring(0, set_fnt.length - 1);\n        this.style({\n          "font-family": set_fnt\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * input value setter/getter\n     * this function is the same as \'text\' function.\n     * \n     * @param (string) input text\n     *                 undefined: call as getter\n     * @return (string) input text\n     * @type parameter\n     */\n\n  }, {\n    key: "value",\n    value: function value(prm) {\n      try {\n        if (undefined !== prm && "string" !== typeof prm) {\n          prm = prm + "";\n        }\n\n        return this.text(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * maximum input text length setter/getter\n     *\n     * @param (number) maximal length\n     *                 undefined: call as getter\n     * @return (mixed) number: maxmal length\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "maxlength",\n    value: function maxlength(len) {\n      try {\n        if (undefined === len) {\n          /* getter */\n          return this.childDom().attrs(\'maxlength\');\n        }\n        /* setter */\n\n\n        if (\'number\' !== typeof len) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.childDom().attrs({\n          maxlength: len\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * secret mode setter/getter\n     *\n     * @param (boolean) true: secret mode (input text is displayed in hiding.)\n     *                  false: normal mode\n     *                  undefined: call as getter\n     * @return (boolean) input mode\n     * @type parameter\n     */\n\n  }, {\n    key: "secret",\n    value: function secret(flg) {\n      try {\n        if (undefined === flg) {\n          /* getter */\n          return \'password\' === this.type() ? true : false;\n        }\n        /* setter */\n\n\n        if (\'boolean\' !== typeof flg) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.type(true === flg ? \'password\' : \'text\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * type attribute setter/getter\n     *\n     * @param (string) type value\n     *                 undefined: call as getter\n     * @return (mixed) type value\n     *                 null: not set\n     * @type private\n     */\n\n  }, {\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.childDom().attrs(undefined === prm ? "type" : {\n          "type": prm\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border color setter/getter\n     *\n     * @param (mixed (color)) string: border color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     *                        undefined: call as getter\n     * @param (key-value) style option\n     * @return (string) color\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return cmputl.color(\'border-color\', prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * clear input text\n     *\n     * @type function\n     */\n\n  }, {\n    key: "clear",\n    value: function clear() {\n      try {\n        this.text(\'\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * focus status setter/getter\n     *\n     * @param (boolean) true: focus input\n     *                  false: defocus input\n     *                  undefined: call as getter\n     * @return (boolean) focus status\n     * @type parameter\n     */\n\n  }, {\n    key: "focus",\n    value: function focus(prm) {\n      try {\n        var ret = _get(_getPrototypeOf(_class.prototype), "focus", this).call(this, prm);\n\n        if (true === prm && true === this.childDom().isPushed()) {\n          /* setter */\n          this.childDom().getRawDom().select();\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * input height setter/getter\n     * \n     * @param (string (size)) input height\n     *                        undefined: call as getter\n     * @param (key-value) style option\n     * @return (mixed) string: input height\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return comutl.sizesum(_get(_getPrototypeOf(_class.prototype), "height", this).call(this), this.sizeOffset());\n        }\n        /* setter */\n\n\n        var set_siz = comutl.sizediff(prm, this.sizeOffset());\n\n        _get(_getPrototypeOf(_class.prototype), "height", this).call(this, set_siz, opt);\n\n        this.style({\n          "font-size": set_siz\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * input width setter/getter\n     *\n     * @param (string (size)) input width\n     *                        undefined: call as getter\n     * @param (key-value) style option\n     * @return (mixed) string: input width\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "width",\n    value: function width(prm, opt) {\n      try {\n        var siz = null;\n\n        if (undefined === prm) {\n          /* getter */\n          try {\n            return comutl.sizesum(_get(_getPrototypeOf(_class.prototype), "width", this).call(this), this.sizeOffset());\n          } catch (e) {\n            return _get(_getPrototypeOf(_class.prototype), "width", this).call(this);\n          }\n        }\n        /* setter */\n\n\n        this.styleDom().style({\n          width: prm\n        }, opt); //this.rootDom()[1].style({ width: prm },opt);\n        //super.width(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * size weight value setter/getter\n     * use for size calculate\n     * \n     * @param (string (size)) size weight\n     *                        undefined: call as getter\n     * @param (string (size)) size object for weight\n     * @type private\n     */\n\n  }, {\n    key: "sizeOffset",\n    value: function sizeOffset(prm) {\n      try {\n        return this.confmng("sizeOffset", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(FormItem);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-input/index.js?')},"./node_modules/mofron-comp-text/index.js":
/*!************************************************!*\
  !*** ./node_modules/mofron-comp-text/index.js ***!
  \************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-text/index.js\n * @brief text component for mofron\n * @license MIT\n */\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * constructor\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: component config\n   * @short text\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Text\');\n\n      _this.shortForm(\'text\');\n      /* init config */\n\n\n      _this.confmng().add("heiWeight", {\n        init: 1.5,\n        type: "number"\n      });\n\n      _this.confmng().add("weight", {\n        type: "number",\n        select: [100, 200, 300, 400, 500, 600, 700, 800, 900]\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.text(\'\'); // default text\n\n        this.size("0.16rem"); // default size\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text setter/getter\n     * \n     * @param (mixed) string: text value\n     *                undefined: call as getter\n     * @return (string) text value\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(val) {\n      try {\n        return this.childDom().text(val);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text getter\n     * \n     * @return (string) text value\n     * @type function\n     */\n\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        return this.text();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text size setter/getter\n     *\n     * @param (mixed) string (size): text size\n     *                undefined: call as getter\n     * @param (key-value) style option [not required]\n     * @return (mixed) string: text size (default is "0.16rem")\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "size",\n    value: function size(val, opt) {\n      try {\n        return cmputl.size(this, "font-size", val, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text height setter/getter\n     * \n     * @param (mixed) string (size): text size\n     *                undefined: call as getter\n     * @param (key-value) style option [not required]\n     * @return (mixed) string: text height (default is "0.24rem")\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        var siz = comutl.getsize(undefined === prm ? this.size() : prm);\n        var siz_buf = null;\n\n        if (\'rem\' === siz.type() || \'px\' === siz.type()) {\n          if (undefined === prm) {\n            siz_buf = siz.value() * this.heiWeight();\n          } else {\n            siz_buf = siz.value() / this.heiWeight();\n          }\n\n          siz_buf = comutl.roundup(siz_buf) + siz.type();\n        } else {\n          siz_buf = siz.toString();\n        }\n\n        if (undefined === prm) {\n          /* gettter */\n          return siz_buf;\n        }\n\n        this.size(siz_buf, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * height weight setter/getter\n     * this value to make \'height\' parameter and real dom size the same\n     * it needs to adjust depending on font difference.\n     * \n     * @param (mixed) number: height weight rate\n     *                undefined: call as getter\n     * @return (number) height weight rate\n     * @type private\n     */\n\n  }, {\n    key: "heiWeight",\n    value: function heiWeight(prm) {\n      try {\n        return this.confmng("heiWeight", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text color setter/getter\n     * \n     * @param (mixed (color)) string: color name, #hex\n     *                array: [red, green, blue, (alpha)]\n     * @param (key-value) style option [not required]\n     * @return (mixed) string: text color\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(val, opt) {\n      try {\n        return cmputl.color(this, \'color\', val, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text font setter/getter\n     * \n     * @param (mixed) string: font name (variable arguments)\n     *                undefined: call as getter\n     * @return (mixed) array: font name\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "font",\n    value: function font() {\n      try {\n        if (0 === arguments.length) {\n          /* getter */\n          return this.style("font-family");\n        }\n        /* setter */\n\n\n        var set_fnt = "";\n\n        for (var aidx = 0; aidx < arguments.length; aidx++) {\n          if ("string" !== typeof arguments[aidx]) {\n            throw new Error("invalid parameter");\n          }\n\n          set_fnt += arguments[aidx] + ",";\n        }\n\n        set_fnt = set_fnt.substring(0, set_fnt.length - 1);\n        this.style({\n          "font-family": set_fnt\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * character spacing setter/getter\n     *\n     * @param (mixed) string(size): spacing size\n     *                undefined: call as getter\n     * @param (key-value) style option [not required]\n     * @return (mixed) string: spacing size\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "space",\n    value: function space(val, opt) {\n      try {\n        return cmputl.size(this, \'letter-spacing\', val, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text thickness setter/getter\n     *\n     * @param (mixed) number: thickness value [100-900]\n     *                null: delete thickness\n     *                undefined: call as getter\n     * @param (key-value) style option [not required]\n     * @return (number) thickness value\n     * @type parameter\n     */\n\n  }, {\n    key: "weight",\n    value: function weight(val, opt) {\n      try {\n        if (undefined === val) {\n          /* getter */\n          return this.style("font-weight");\n        }\n        /* setter */\n\n\n        this.style({\n          \'font-weight\': val\n        }, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-text/index.js?')},"./node_modules/mofron-comp-txtheader/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-comp-txtheader/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  mofron-comp-txtheader/index.js\n * @brief text header component\n *        text in this component is positioned centrally in vertical in automatically. \n * @license MIT\n */\nvar Header = __webpack_require__(/*! mofron-comp-header */ "./node_modules/mofron-comp-header/index.js");\n\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar Synhei = __webpack_require__(/*! mofron-effect-synchei */ "./node_modules/mofron-effect-synchei/index.js");\n\nvar cmputl = mofron.util.component;\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Header) {\n  _inherits(_class, _Header);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (mixed) text parameter\n   *                key-value: component option\n   * @short text\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'TxtHeader\');\n\n      _this.shortForm(\'text\');\n\n      if (0 < arguments.length) {\n        _this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.style({\n          \'align-items\': \'center\'\n        });\n        this.child(this.text());\n        this.text().effect(new Synhei(this));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter text\n     *\n     * @param (mixed) string: text contents\n     *                mofron-comp-text: update text component\n     * @param (key-value) text config\n     * @return (mofron-comp-text) text contents\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(txt, cnf) {\n      try {\n        if (undefined !== cnf) {\n          if (true === comutl.isinc(txt, "Text")) {\n            txt.config(cnf);\n          } else {\n            this.text().config(cnf);\n          }\n        }\n\n        if (\'string\' === typeof txt) {\n          this.text().text(txt);\n          return;\n        }\n\n        return this.innerComp(\'text\', txt, Text);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text position and size offset\n     * \n     * @param (string (size)) left offset position\n     * @param (string (size)) height offset position\n     * \n     */\n\n  }, {\n    key: "txtpos",\n    value: function txtpos(lft, hei) {\n      try {\n        this.text().style({\n          "margin-left": lft\n        });\n        var syn = this.text().effect({\n          name: "SyncHei"\n        });\n\n        if (true === comutl.isinc(syn, "SyncHei")) {\n          syn.offset(hei);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Header);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-txtheader/index.js?')},"./node_modules/mofron-effect-border/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-border/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports){eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-border/index.js\n * @brief border effect for mofron\n *        set border style to target component\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   * \n   * @param (mixed) width parameter\n   *                key-value: effect config\n   * @param (mixed) color parameter\n   * @short width,color\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname('Border');\n\n      _this.shortForm('width', 'color');\n\n      _this.transition([\"border-width\", \"border-top-width\", \"border-bottom-width\", \"border-left-width\", \"border-right-width\", \"border-top-left-width\", \"border-top-right-width\", \"border-bottom-left-width\", \"border-bottom-right-width\", \"border-color\", \"border-top-color\", \"border-bottom-color\", \"border-left-color\", \"border-right-color\", \"border-top-left-color\", \"border-top-right-color\", \"border-bottom-left-color\", \"border-bottom-right-color\"]);\n      /* init config */\n\n\n      _this.confmng().add('width', {\n        type: 'size',\n        init: \"0.01rem\"\n      });\n\n      _this.confmng().add('style', {\n        type: 'string',\n        init: 'solid',\n        select: ['none', 'hidden', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset', 'dashed', 'dotted']\n      });\n\n      _this.confmng().add('position', {\n        type: 'string',\n        init: 'all',\n        select: ['all', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right']\n      });\n\n      _this.confmng().add('color', {\n        type: 'color',\n        init: [90, 90, 90]\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * effect config\n   * \n   * @param (component) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: \"contents\",\n    value: function contents(cmp) {\n      try {\n        var set_style = {};\n        var pos = 'all' === this.position() ? 'border-' : 'border-' + this.position() + '-';\n        set_style[pos + 'width'] = this.width().toString();\n        set_style[pos + 'style'] = this.style();\n        set_style[pos + 'color'] = this.color().toString();\n        cmp.style(set_style);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border width\n     * \n     * @param (string) css value of border width\n     * @return (string) css value of border width\n     * @type parameter\n     */\n\n  }, {\n    key: \"width\",\n    value: function width(prm) {\n      try {\n        return this.confmng('width', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter border style\n     *\n     * @param (string) css value of border style (default is 'solid')\n     *                 ('none', 'hidden', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset', 'dashed', 'dotted')\n     * @return (string) css value of border style\n     * @type parameter\n     */\n\n  }, {\n    key: \"style\",\n    value: function style(prm) {\n      try {\n        return this.confmng('style', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border position\n     * \n     * @param (string) border target position (default is 'all')\n     *                 ('all', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right')\n     * @return (string) css value of border type\n     * @type parameter\n     */\n\n  }, {\n    key: \"position\",\n    value: function position(prm) {\n      try {\n        return this.confmng('position', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border color\n     * \n     * @param (mixed (color)) string: color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @return (mixed (color)) border color\n     * @type parameter\n     */\n\n  }, {\n    key: \"color\",\n    value: function color(prm) {\n      try {\n        return this.confmng('color', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron[\"class\"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-border/index.js?")},"./node_modules/mofron-effect-fade/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-effect-fade/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-fade/index.js\n * @brief fade effect for mofron\n * @author simpart\n */\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize fade effect\n   * \n   * @param (mixed) boolean: value parameter\n   *                object: effect config\n   * @param (number) speed parameter\n   * @short value,speed\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Fade\');\n\n      _this.confmng().add("value", {\n        type: "boolean",\n        init: true\n      });\n\n      _this.shortForm("value", "speed");\n      /* init config */\n\n\n      _this.speed(700);\n\n      _this.transition("opacity");\n      /* opacity setting */\n\n\n      _this.beforeEvent(function (bf_eff) {\n        try {\n          var stval = {\n            \'opacity\': true === bf_eff.value() ? 0 : 1\n          };\n          cmputl.rstyle(bf_eff.component(), stval);\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      });\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * effect contents\n   * \n   * @param (component) effect target component object\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        cmputl.rstyle(cmp, {\n          \'opacity\': true === this.value() ? 1 : 0\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * fade type value\n     * \n     * @param (boolean) true: fade-in effect\n     *                  false: fade-out effect\n     * @return (boolean) fade type\n     * @type parameter\n     */\n\n  }, {\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.confmng("value", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-fade/index.js?')},"./node_modules/mofron-effect-hrzpos/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-hrzpos/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-hrzpos/index.js\n * @brief horizonal position effect for mofron component\n *        the component is positioned specified parameter that is \'center\' or \'left\' and \'right\'.\n * @license MIT\n */\nvar cmputl = mofron.util.component;\nvar comutl = mofron.util.common;\n\nvar transfm = __webpack_require__(/*! mofron-util-transform */ "./node_modules/mofron-util-transform/index.js");\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   * \n   * @param (mixed) type parameter\n   *                key-value: effect config\n   * @param (string) offset parameter\n   * @short type,offset\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'HrzPos\');\n\n      _this.shortForm(\'type\', \'offset\');\n      /* init config */\n\n\n      _this.confmng().add("offset", {\n        type: "size"\n      });\n\n      _this.confmng().add("type", {\n        type: "string",\n        init: "center",\n        select: ["center", "left", "right"]\n      });\n      /* set config */\n\n\n      _this.innerTgt(false);\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * effect contents\n   * \n   * @param (mofron.class.Component) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var rdom = cmp.rootDom();\n\n        for (var ridx in rdom) {\n          if (true === comutl.isinc(cmp, "Text")) {\n            /* set text component position */\n            this.txtpos(rdom[ridx]);\n            continue;\n          }\n          /* set other component position */\n\n\n          var cmp_pos = rdom[ridx].style("position");\n\n          if ("center" === this.type()) {\n            if ("fixed" === cmp_pos || "absolute" === cmp_pos) {\n              this.lftpos(rdom[ridx]);\n            } else {\n              rdom[ridx].style({\n                "display": "block"\n              });\n              this.mgnpos(rdom[ridx]);\n            }\n          } else {\n            if ("relative" === cmp_pos) {\n              this.mgnpos(rdom[ridx]);\n            } else if ("absolute" === cmp_pos || "fixed" === cmp_pos) {\n              this.lftpos(rdom[ridx]);\n            } else {\n              if (null !== cmp.parent()) {\n                rdom[ridx].style({\n                  "position": "relative"\n                });\n                this.mgnpos(rdom[ridx]);\n              } else {\n                rdom[ridx].style({\n                  "position": "absolute"\n                });\n                this.lftpos(rdom[ridx]);\n              }\n            }\n          }\n\n          if ("flex" === rdom[ridx].parent().style("display") || "flex" === cmputl.dispbuff(rdom[ridx].parent())) {\n            break;\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text component position\n     * \n     * @param (mofron.class.Dom) dom objedt\n     * @type private\n     */\n\n  }, {\n    key: "txtpos",\n    value: function txtpos(dom) {\n      try {\n        if (null !== dom.parent() && ("flex" === dom.parent().style("display") || "flex" === cmputl.dispbuff(dom.parent()))) {\n          this.mgnpos(dom);\n        } else if ("absolute" === dom.style("position") || "flex" === dom.style("position")) {\n          this.lftpos(dom);\n        } else {\n          dom.style({\n            \'text-align\': this.type()\n          });\n\n          if (null !== this.offset()) {\n            dom.style({\n              "position": "relative"\n            });\n\n            if ("right" !== this.type()) {\n              dom.style({\n                "left": this.offset()\n              });\n            } else {\n              dom.style({\n                "right": this.offset()\n              });\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set margin position\n     * \n     * @param (mofron.class.Dom) dom object\n     * @type private\n     */\n\n  }, {\n    key: "mgnpos",\n    value: function mgnpos(dom) {\n      try {\n        var off = this.offset();\n\n        if (\'center\' === this.type()) {\n          dom.style({\n            "margin-right": "auto",\n            "margin-left": "auto"\n          });\n\n          if (null !== off) {\n            dom.style({\n              "position": "relative",\n              "left": off\n            });\n          }\n        } else if (\'left\' === this.type()) {\n          dom.style({\n            "margin-right": "auto",\n            "margin-left": "0rem"\n          });\n\n          if (null !== off) {\n            dom.style({\n              "margin-left": off\n            });\n          }\n        } else {\n          dom.style({\n            "margin-right": "0rem",\n            "margin-left": "auto"\n          });\n\n          if (null !== off) {\n            dom.style({\n              "margin-right": off\n            });\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set left position\n     *\n     * @param (mofron.class.Dom) dom object\n     * @type private\n     */\n\n  }, {\n    key: "lftpos",\n    value: function lftpos(dom) {\n      try {\n        var off = this.offset();\n\n        if (\'center\' === this.type()) {\n          dom.style({\n            "left": "50%"\n          });\n\n          if (null === off || "%" !== comutl.sizetype(off)) {\n            transfm(dom, "-50%");\n          } else {\n            transfm(dom, comutl.sizesum("-50%", off));\n          }\n        } else if (\'left\' === this.type()) {\n          dom.style({\n            "left": null !== off ? off : "0rem"\n          });\n        } else if (\'right\' === this.type()) {\n          dom.style({\n            "right": null !== off ? off : "0rem"\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * position type setter/getter\n     * \n     * @param (string) set position type (\'center\',\'left\',\'right\')\n     *                 undefind: call as getter\n     * @return (string) position type\n     * @type parameter\n     */\n\n  }, {\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * position offset setter/getter\n     * \n     * @param (string(size)) position offset size\n     *                       undefined: call as getter\n     * @return (mixed) string(size): position offset size\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(prm) {\n      try {\n        return this.confmng("offset", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-hrzpos/index.js?')},"./node_modules/mofron-effect-radius/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-radius/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-radius/index.js\n * @brief radius effect for mofron\n *        this effect makes the components of outside rounded style\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize radius effect\n   *\n   * @param (mixed) value parameter\n   *                key-value: effect config\n   * @short value\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Radius\');\n\n      _this.shortForm(\'value\');\n      /* init config */\n\n\n      _this.confmng().add("value", {\n        type: "size",\n        init: "0.5rem"\n      });\n\n      _this.confmng().add("position", {\n        list: true,\n        select: ["top-left", "top-right", "bottom-left", "bottom-right"]\n      });\n\n      _this.transition(["border-radius", "border-top-left-radius", "border-top-right-radius", "border-bottom-left-radius", "border-bottom-right-radius"]);\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * radius size\n   *\n   * @param (string (size)) radius size\n   * @return (string (size)) radius size\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.confmng("value", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * radius target position\n     * each position will be targeted if nothing is set \n     * \n     * @param (mixed) array: position list\n     *                string: target position ("top-left","top-right","bottom-left","bottom-right")\n     * @return (array) position list\n     * @type parameter\n     */\n\n  }, {\n    key: "position",\n    value: function position(prm) {\n      try {\n        return this.confmng(\'position\', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * effect contents\n     * \n     * @param (component) target component\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var pos = this.position();\n        var val = this.value().toString();\n\n        if (0 === pos.length) {\n          cmp.style({\n            \'border-radius\': val\n          }, {\n            bpref: true\n          });\n        } else {\n          var set_sty = {};\n\n          for (var tidx in pos) {\n            set_sty[\'border-\' + pos[tidx] + \'-radius\'] = val;\n          }\n\n          cmp.style(set_sty, {\n            bpref: true\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-radius/index.js?')},"./node_modules/mofron-effect-shadow/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-shadow/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-shadow/index.js\n * @brief shadow effect for mofron\n *        this effect makes the component has a shadow.\n * @feature the size changes according to the value of the \'value\' parameter.\n *          the blur percentage changes according to the value of the \'blur\' parameter.\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   *\n   * @param (mixed) value parameter\n   *                key-value: effect config\n   * @param color parameter\n   * @short value,color\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Shadow\');\n\n      _this.shortForm(\'value\', \'color\');\n\n      _this.transition(["box-shadow", "webkit-box-shadow", "-moz-box-shadow", "-o-box-shadow", "-ms-box-shadow"]);\n      /* init config */\n\n\n      _this.confmng().add("value", {\n        type: "size",\n        init: "0.015rem"\n      });\n\n      _this.confmng().add("blur", {\n        type: "size",\n        init: "0rem"\n      });\n\n      _this.confmng().add(\'color\', {\n        type: "color",\n        init: [190, 190, 190]\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * shadow size\n   *\n   * @param (string (size)) shadow size (css value)\n   * @return (string (size)) shadow size (css value)\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.confmng("value", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * blur size value\n     * \n     * @param (string (size)) blur size value\n     * @return (string (size)) blur size value\n     * @type parameter\n     */\n\n  }, {\n    key: "blur",\n    value: function blur(prm) {\n      try {\n        return this.confmng("blur", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * shadow color\n     *\n     * @param (string (size)) shadow color (css value)\n     * @return (string (size)) shadow color (css value)\n     * @type parameter\n     */\n\n  }, {\n    key: "color",\n    value: function color(prm) {\n      try {\n        return this.confmng("color", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * effect contents\n     * \n     * @param (component) target componet\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var str_val = this.value().toString();\n        var sum_val = comutl.sizesum(str_val, comutl.sizesum(str_val, str_val));\n        var set_val = {\n          "box-shadow": sum_val + \' \' + sum_val + \' \' + this.blur().toString() + \' \' + \'0rem \' + this.color().toString()\n        };\n        cmp.style(set_val, {\n          bpref: true\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-shadow/index.js?')},"./node_modules/mofron-effect-synchei/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-effect-synchei/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-synchei/index.js\n * @brief synchronize height of target component and height of effect component\n *        this effect resizes height of a target component when the height of the target component changed.\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * constructor\n   * \n   * @param (mixed) string: targetComp parameter\n   *                key-value: effect config\n   * @param (string) offset parameter\n   * @short targetComp,offset\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'SyncHei\');\n\n      _this.shortForm(\'targetComp\', \'offset\');\n      /* init config */\n\n\n      _this.confmng().add(\'targetComp\', {\n        type: \'Component\'\n      });\n\n      _this.confmng().add(\'offset\', {\n        type: \'size\'\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * setter/getter for height listen target component\n   * it triggers this effect when height of target component was changed.\n   *\n   * @param (mofron.class.Component) target component\n   *                                 undefined: call as getter\n   * @return (mixed) mofron.class.Component: target component\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "targetComp",\n    value: function targetComp(prm) {\n      try {\n        var ret = this.confmng(\'targetComp\', prm);\n\n        if (undefined !== prm) {\n          var syn_fnc = function syn_fnc(p1, p2, sync) {\n            try {\n              sync.execute();\n            } catch (e) {\n              console.error(e.stack);\n              throw e;\n            }\n          };\n\n          prm.styleDom().style().listener(\'height\', syn_fnc, this);\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * offset value setter/getter\n     * this value is used for height adjustment\n     *\n     * @param (string(size)) offset value (default is \'0rem\')\n     *                       undefined: call as getter\n     * @return (string) offset value\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(prm) {\n      try {\n        return this.confmng(\'offset\', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * synchronize height size\n     *\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        if (null === this.targetComp()) {\n          this.targetComp(this.component().parent());\n        }\n\n        cmp.height(comutl.sizesum(this.targetComp().height(), this.offset()));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-synchei/index.js?')},"./node_modules/mofron-effect-syncwin/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-effect-syncwin/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-syncwin/index.js\n * @brief synchronize component with window\n *        target component size is changed even if the window size is changed.\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nvar get_offsiz = function get_offsiz(off) {\n  try {\n    var ret = [];\n\n    for (var oidx in off) {\n      if (null === off[oidx]) {\n        ret.push(undefined);\n        continue;\n      }\n\n      var siz = comutl.getsize(off[oidx]);\n\n      if (\'%\' === siz.type()) {\n        var oval = siz.value() / 100;\n        ret.push(0 == oidx ? window.innerWidth * oval + "px" : window.innerHeight * oval + "px");\n      } else {\n        ret.push(siz.toPixel() + \'px\');\n      }\n    }\n\n    return ret;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   * \n   * @param (mixed) valid config parameter\n   *                dict: effect config list\n   * @param (mixed) offset config parameter\n   * @short valid,offset\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'SyncWin\');\n\n      _this.shortForm(\'valid\', \'offset\');\n      /* init config */\n\n\n      _this.confmng().add("x_valid", {\n        type: "boolean",\n        init: true\n      });\n\n      _this.confmng().add("y_valid", {\n        type: "boolean",\n        init: true\n      });\n\n      _this.confmng().add("x_offset", {\n        type: "size"\n      });\n\n      _this.confmng().add("y_offset", {\n        type: "size"\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * enable synchronize window size\n   * \n   * @param (component) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(tgt) {\n      try {\n        var off = get_offsiz(this.offset());\n\n        if (true === this.valid()[0]) {\n          /* set horizon size */\n          try {\n            tgt.width(comutl.sizesum(window.innerWidth + \'px\', off[0]));\n          } catch (e) {\n            tgt.width(window.innerWidth + \'px\');\n          }\n        }\n\n        if (true === this.valid()[1]) {\n          /* set vertical size */\n          try {\n            tgt.height(comutl.sizesum(window.innerHeight + \'px\', off[1]));\n          } catch (e) {\n            tgt.height(window.innerHeight + \'px\');\n          }\n        }\n\n        if (false === this.isInited()) {\n          var fnc = function fnc(eff) {\n            try {\n              eff.execute();\n            } catch (e) {\n              console.error(e.stack);\n              throw e;\n            }\n          };\n\n          mofron.window.resizeEvent(fnc, this);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set x,y valid flag\n     * \n     * @param (boolean) valid flag for horizon\n     * @param (boolean) valid flag for vertical\n     * @return (array) [x-flag, y-flag ]\n     * @type pararmeter\n     */\n\n  }, {\n    key: "valid",\n    value: function valid(x, y) {\n      try {\n        if (undefined === x) {\n          /* getter */\n          return [this.x_valid(), this.y_valid()];\n        }\n        /* setter */\n\n\n        this.x_valid(x);\n        this.y_valid(y);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * horizonal valid flag setter/getter\n     * \n     * @param (boolean) true: enabled horizonal sync [default]\n     *                  false: disabled horizonal sync\n     *                  undefined: call as getter\n     * @return (boolean) horizonal valid flag\n     * @type parameter\n     */\n\n  }, {\n    key: "x_valid",\n    value: function x_valid(prm) {\n      try {\n        return this.confmng("x_valid", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * vertical valid flag setter/getter\n     * \n     * @param (boolean) true: enabled vertical sync [default]\n     *                  false: disabled vertical sync\n     *                  undefined: call as getter\n     * @return (boolean) vertival valid flag\n     * @type parameter\n     */\n\n  }, {\n    key: "y_valid",\n    value: function y_valid(prm) {\n      try {\n        return this.confmng("y_valid", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter offset size\n     * \n     * @param (string (size)) horizonal offset size\n     * @param (string (size)) vertical offset size\n     * @return (array) [horizon offset size, vertical offset size]\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(x, y) {\n      try {\n        if (undefined === x) {\n          /* getter */\n          return [this.x_offset(), this.y_offset()];\n        }\n        /* setter */\n\n\n        this.x_offset(x);\n        this.y_offset(y);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * horizonal offset size setter/getter\n     * \n     * @param (string(size)) horizonal offset size\n     * @return (string(size)) horizonal offset size\n     * @type parameter\n     */\n\n  }, {\n    key: "x_offset",\n    value: function x_offset(prm) {\n      try {\n        return this.confmng("x_offset", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * vertical offset size setter/getter\n     * \n     * @param (string(size)) vertical offset size\n     * @return (string(size)) vertical offset size\n     * @type parameter\n     */\n\n  }, {\n    key: "y_offset",\n    value: function y_offset(prm) {\n      try {\n        return this.confmng("y_offset", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-syncwin/index.js?')},"./node_modules/mofron-effect-vrtpos/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-vrtpos/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-vrtpos/index.js\n * @brief vertical position effect for mofron component\n *        the component is positioned specified parameter that is \'center\' or \'top\' and \'bottom\'.\n * @license MIT\n */\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nvar transfm = __webpack_require__(/*! mofron-util-transform */ "./node_modules/mofron-util-transform/index.js");\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize vertical position effect\n   *\n   * @param (mixed) type config parameter\n   *                key-value: effect config list\n   * @param offset config parameter\n   * @short type,offset\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("VrtPos");\n\n      _this.shortForm("type", "offset");\n      /* init config */\n\n\n      _this.confmng().add("type", {\n        type: "string",\n        select: ["top", "center", "bottom"],\n        init: "center"\n      });\n\n      _this.confmng().add("offset", {\n        type: "size"\n      });\n      /* set config */\n\n\n      _this.innerTgt(false);\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * effet contents\n   * \n   * @param (mofron.class.Component) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var rdom = cmp.rootDom();\n\n        for (var ridx in rdom) {\n          if (true === comutl.isinc(cmp, "Text")) {\n            this.txtpos(rdom[ridx]);\n            return;\n          } else if ("absolute" === rdom[ridx].style("position") || "relative" === rdom[ridx].style("position") || "fixed" === rdom[ridx].style("position")) {\n            this.toppos(rdom[ridx]);\n          } else if ("flex" === rdom[ridx].parent().style("display") || "flex" === cmputl.dispbuff(rdom[ridx])) {\n            this.mgnpos(rdom[ridx]);\n          } else {\n            rdom[ridx].style({\n              "position": "relative"\n            }, {\n              passive: true\n            });\n            this.toppos(rdom[ridx]);\n          }\n\n          if ("flex" !== rdom[ridx].parent().style("display")) {\n            break;\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set text component position\n     * \n     * @param (mofron.class.Dom) dom object\n     * @type private\n     */\n\n  }, {\n    key: "txtpos",\n    value: function txtpos(dom) {\n      try {\n        var off = this.offset();\n        var pnt = dom.parent();\n\n        if (null !== pnt) {\n          var pnt_disp = "none" === pnt.style("display") ? cmputl.dispbuff(pnt) : pnt.style("display");\n\n          if ("flex" === pnt_disp || \'grid\' === pnt_disp) {\n            if ("center" === this.type()) {\n              pnt.style({\n                "align-items": "center"\n              });\n            } else if ("bottom" === this.type()) {\n              pnt.style({\n                "align-items": "flex-end"\n              });\n            }\n\n            if (null !== off) {\n              dom.style({\n                "position": "relative"\n              }, {\n                passive: true\n              });\n              dom.style({\n                "top": off\n              });\n            }\n\n            return;\n          }\n        }\n\n        dom.style({\n          "position": "relative"\n        }, {\n          passive: true\n        });\n        this.toppos(dom);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set position by top value\n     * \n     * @param (mofron.class.Dom) effect target component\n     * @type private\n     */\n\n  }, {\n    key: "toppos",\n    value: function toppos(dom) {\n      try {\n        var off = this.offset();\n\n        if ("center" === this.type()) {\n          dom.style({\n            "top": "50%"\n          });\n          transfm(dom, undefined, "-50%");\n\n          if (null !== off) {\n            dom.style({\n              "margin-top": off\n            });\n          }\n        } else if ("top" === this.type()) {\n          dom.style({\n            "top": null !== off ? off : "0rem"\n          });\n        } else {\n          dom.style({\n            "bottom": null !== off ? off : "0rem"\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set position by margin value\n     * \n     * @param (mofron.class.Dom) dom object\n     * @type private\n     */\n\n  }, {\n    key: "mgnpos",\n    value: function mgnpos(dom) {\n      try {\n        var off = this.offset();\n\n        if ("center" === this.type()) {\n          dom.style({\n            "margin-top": "auto",\n            "margin-bottom": "auto"\n          });\n\n          if (null !== off) {\n            dom.style({\n              "position": "relative"\n            }, {\n              passive: true\n            });\n            dom.style({\n              "top": off\n            });\n          }\n        } else if ("top" === this.type()) {\n          dom.style({\n            "margin-top": null !== off ? off : "0rem",\n            "margin-bottom": "auto"\n          });\n        } else {\n          dom.style({\n            "margin-top": "auto",\n            "margin-bottom": null !== off ? off : "0rem"\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * position type setter/getter\n     *\n     * @param (string) position type (center,top,bottom)\n     *                 undefined: call as getter\n     * @return (string) position type\n     * @type parameter\n     */\n\n  }, {\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * offset size setter/getter\n     *\n     * @param (string(size)) offset size\n     *                       undefined: call as getter\n     * @return (mofron.class.Size) offset size\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(prm) {\n      try {\n        return this.confmng("offset", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-vrtpos/index.js?')},"./node_modules/mofron-event-click/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-event-click/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-event-click/index.js\n * @brief click event for mofron component\n *        it executes an event function when the component is clicked\n * ## event function parameter\n *  - component: event target component object\n *  - object: MouseEvent object of addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nvar Common = __webpack_require__(/*! mofron-event-common */ "./node_modules/mofron-event-common/index.js");\n\nmodule.exports = /*#__PURE__*/function (_Common) {\n  _inherits(_class, _Common);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize click event\n   * \n   * @param (mixed) listener parameter\n   *                key-value: event config\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("Click");\n\n      _this.shortForm("listener");\n      /* init config */\n\n\n      _this.confmng().add("pointer", {\n        type: "boolean",\n        init: true\n      });\n\n      _this.type("click");\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * add click event to target component.\n   * \n   * @param (component) event target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(tgt) {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "contents", this).call(this, tgt);\n\n        if (true === this.pointer()) {\n          this.component().style({\n            \'cursor\': \'pointer\'\n          }, {\n            passive: true\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * mouse cursor style\n     *\n     * @param (boolean) true: mouse-in cursor is pointer [default]\n     *                  false: mouse-in coursor is default\n     * @return (boolean) mouse-in cursor style\n     * @type parameter\n     */\n\n  }, {\n    key: "pointer",\n    value: function pointer(flg) {\n      try {\n        return this.confmng("pointer", flg);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Common);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-click/index.js?')},"./node_modules/mofron-event-common/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron-event-common/index.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-event-common/index.js\n * @brief common event for mofron\n *        set addEventListener of target object\n *        it is possible to use addEventListener() for general by setting the parameter of the type method.\n * ## event function parameter\n *  - component: event target component object\n *  - object: event object of addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Event) {\n  _inherits(_class, _mofron$class$Event);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize common event\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: event config\n   * @short listener,type\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("Common");\n\n      _this.shortForm("listener", "type");\n      /* init config */\n\n\n      _this.confmng().add("type", {\n        type: "string"\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * event type\n   * \n   * @param (string) event type\n   * @return (string) event type\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * event contents\n     * \n     * @param (mofron.class.Dom) event target dom\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(tgt_dom) {\n      try {\n        var evt_obj = this;\n        tgt_dom.getRawDom().addEventListener(this.type(), function (e) {\n          try {\n            evt_obj.execListener(e);\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        }, false);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Event);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-common/index.js?')},"./node_modules/mofron-event-link/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-event-link/index.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-event-link/index.js\n * @brief enable link to target component\n * ## event function parameter\n *  - component: event target component object\n *  - event: "click" event object by addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nvar Click = __webpack_require__(/*! mofron-event-click */ "./node_modules/mofron-event-click/index.js");\n\nmodule.exports = /*#__PURE__*/function (_Click) {\n  _inherits(_class, _Click);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize event\n   * \n   * @param (mixed) url parameter\n   *                key-value: event config\n   * @param (boolean) newtab parameter\n   * @short url,newtab\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("Link");\n\n      _this.shortForm("url", "newtab");\n\n      _this.confmng().add("url", {\n        type: "string",\n        init: "./"\n      });\n\n      _this.confmng().add("newtab", {\n        type: "boolean",\n        init: false\n      });\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * event contents\n   * set url jump event to click handler\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(tgt_dom) {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "contents", this).call(this, tgt_dom);\n\n        var link = this;\n        this.listener(function () {\n          try {\n            if (true === link.newtab()) {\n              window.open(link.url(), \'_blank\');\n            } else {\n              window.location.href = link.url();\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        }, this);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * jump url\n     *\n     * @param (string) jump url (default is \'./\')\n     * @type parameter\n     */\n\n  }, {\n    key: "url",\n    value: function url(prm) {\n      try {\n        return this.confmng("url", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * newtab flag\n     * \n     * @param (boolean) true: jump to url by newtab (default)\n     *                  false: jump to url by current tab\n     * @type parameter\n     */\n\n  }, {\n    key: "newtab",\n    value: function newtab(prm) {\n      try {\n        return this.confmng("newtab", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Click);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-link/index.js?')},"./node_modules/mofron-event-oncommon/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-event-oncommon/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-event-oncommon/index.js\n * @brief on-event common module for mofron\n * ## event function parameter\n *  - component: event target component object\n *  - object: event object (depend on \'ename\' parameter)\n *  - mixed: user specified parameter\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Event) {\n  _inherits(_class, _mofron$class$Event);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize event\n   * \n   * @param (mixed) listener config parameter\n   *                key-value: event config list\n   * @param (string) ename config parameter\n   * @short listener,ename\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'OnCommon\');\n\n      _this.shortForm("listener", "ename");\n      /* init config */\n\n\n      _this.confmng().add("ename", {\n        type: "string"\n      });\n      /* add config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * event name setter/getter\n   * \n   * @param (string) event name\n   *                 undefined: call as getter\n   * @return (string) event name\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "ename",\n    value: function ename(prm) {\n      try {\n        return this.confmng("ename", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * event contents\n     * \n     * @param (mofron.class.Dom) event target dom\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(tgt_dom) {\n      try {\n        var ename = this.ename();\n\n        if (null === ename || undefined === tgt_dom.getRawDom()[ename]) {\n          throw new Error(\'invalid event name : \' + ename);\n        }\n\n        var evt_obj = this;\n        var evt_buff = tgt_dom.getRawDom()[ename];\n\n        tgt_dom.getRawDom()[ename] = function (ev) {\n          try {\n            if ("function" === typeof evt_buff) {\n              evt_buff(ev);\n            }\n\n            evt_obj.execListener(ev);\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Event);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-oncommon/index.js?')},"./node_modules/mofron-layout-grid/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-layout-grid/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-layout-grid/index.js\n * @brief grid layout for mofron\n *        it makes component size to a specified size, and positions by horizontal.\n *        when it positioned at the horizontal end, it turns back on the left side and positions under its.\n * @attention please specify either the ratio parameter or the width parameter\n *            it gives priority to ratio parameter if users specified both\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Layout) {\n  _inherits(_class, _mofron$class$Layout);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize layout\n   * \n   * @param (mixed) ratio parameter\n   *                key-value: layout config\n   * @short ratio\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("Grid");\n\n      _this.shortForm("ratio");\n      /* init config */\n\n\n      _this.confmng().add("ratio", {\n        type: "array",\n        init: [25, 25, 25, 25]\n      });\n\n      _this.confmng().add("width", {\n        type: "array"\n      });\n\n      _this.confmng().add("height", {\n        type: "size"\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * layout contents\n   * \n   * @param (number) child index\n   * @param (component) layout target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(idx, tgt) {\n      try {\n        var wid = this.width();\n\n        if (0 === idx) {\n          this.component().style({\n            "display": "flex",\n            "flex-wrap": "wrap"\n          });\n\n          if (null !== wid) {\n            var cmp_wid = null;\n\n            for (var widx in wid) {\n              cmp_wid = comutl.sizesum(cmp_wid, wid[widx]);\n            }\n\n            this.component().width(cmp_wid);\n          }\n        }\n        /* set width */\n\n\n        if (null !== this.width()) {\n          tgt.width(this.width()[idx % this.width().length]);\n        } else {\n          tgt.width(this.ratio()[idx % this.ratio().length] + \'%\');\n        }\n        /* set height */\n\n\n        if (null !== this.height()) {\n          tgt.height(this.height());\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * units width ratio of grid\n     * \n     * @param (array) units width ratio [number,number,..]\n     * @return (array) units width ratio\n     * @attention parameter sum should be 100\n     * @type parameter\n     */\n\n  }, {\n    key: "ratio",\n    value: function ratio(prm) {\n      try {\n        var ret = this.confmng("ratio", prm);\n\n        if (undefined !== prm) {\n          for (var pidx in prm) {\n            if ("number" !== typeof prm[pidx]) {\n              throw new Error("invalid parameter");\n            }\n          }\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * width size for grid target\n     * \n     * @param (array) width size for grid target [string,string,..]\n     * @return (array) width size for grid target\n     * @type parameter\n     */\n\n  }, {\n    key: "width",\n    value: function width(prm) {\n      try {\n        var ret = this.confmng("size", prm);\n\n        if (undefined !== prm) {\n          for (var pidx in prm) {\n            comutl.getsize(prm[pidx]);\n          }\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * height size for grid target\n     *\n     * @param (string (size)) height size for grid target\n     * @return (string (size)) height size for grid target\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm) {\n      try {\n        return this.confmng("height", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Layout);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-grid/index.js?')},"./node_modules/mofron-layout-horizon/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-layout-horizon/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-layout-horizon/index.js\n * @brief horizon layout for mofron\n *        target component of children is positioned horizontally.\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Layout) {\n  _inherits(_class, _mofron$class$Layout);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize layout\n   * \n   * @type private\n   */\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Horizon\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * set horizon style\n   *\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "execute",\n    value: function execute() {\n      try {\n        this.component().style(_defineProperty({\n          \'display\': \'-webkit-flex\'\n        }, "display", \'flex\'));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Layout);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-horizon/index.js?')},"./node_modules/mofron-layout-hrzcenter/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/mofron-layout-hrzcenter/index.js ***!
  \*******************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-layout-hrzcenter/index.js\n * @brief horizon center layout\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Layout) {\n  _inherits(_class, _mofron$class$Layout);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize horizon center layout\n   * \n   * @param (mixed) object: layout option\n   *                number: center rate\n   * @param (string) center type\n   * @short rate,type\n   * @type private\n   */\n  function _class(po, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'HrzCenter\');\n\n      _this.shortForm(\'rate\', \'type\');\n\n      _this.confmng().add(\'rate\', {\n        type: \'number\',\n        init: 80\n      });\n\n      _this.confmng().add(\'type\', {\n        type: \'string\',\n        select: [\'relative\', \'margin\', \'padding\'],\n        init: \'relative\'\n      });\n\n      if (0 < arguments.length) {\n        _this.config(po, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * layout contents\n   *\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(idx, tgt) {\n      try {\n        var tdom = tgt.rootDom();\n        var pdom = tgt.rootDom()[0].parent();\n\n        if (null !== pdom && "flex" === pdom.style("display")) {\n          tdom = [tgt.rootDom()[0]];\n        }\n\n        if (\'relative\' === this.type()) {\n          for (var tidx in tdom) {\n            tdom[tidx].style({\n              position: this.type(),\n              left: (100 - this.rate()) / 2 + \'%\',\n              width: this.rate() + \'%\'\n            });\n          }\n        } else {\n          var set_style = {\n            width: this.rate() + \'%\'\n          };\n          set_style[this.type() + \'-left\'] = (100 - this.rate()) / 2 + \'%\';\n\n          for (var _tidx in tdom) {\n            tdom[_tidx].style(set_style);\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter center rate\n     *\n     * @param (number) center rate \n     *                 undefined: call as getter\n     * @return (number) center rate\n     * @type parameter\n     */\n\n  }, {\n    key: "rate",\n    value: function rate(prm) {\n      try {\n        if (undefined !== prm && (0 > prm || 100 < prm)) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        return this.confmng("rate", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter center type\n     *\n     * @param (string) center type\n     *                 undefined: call as getter\n     * @return (string) center type\n     * @type parameter\n     */\n\n  }, {\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Layout);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-hrzcenter/index.js?')},"./node_modules/mofron-layout-margin/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-layout-margin/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports){eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-layout-margin/index.js\n * @brief margin layout of mofron\n *        target child component is got margin style.\n * @license MIT\n */\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Layout) {\n  _inherits(_class, _mofron$class$Layout);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize margin layout\n   *\n   * @param (mixed) type config parameter\n   *                dict: layout config list\n   * @param (string(size)) value config parameter\n   * @short type,value\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname('Margin');\n\n      _this.shortForm('type', 'value');\n      /* init config */\n\n\n      _this.confmng().add('type', {\n        type: 'string',\n        select: ['top', 'right', 'bottom', 'left', 'all']\n      });\n\n      _this.confmng().add('value', {\n        type: 'size',\n        init: '0.25rem'\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * margin layout\n   *\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: \"contents\",\n    value: function contents(idx, tgt) {\n      try {\n        var mg = null === this.type() || \"all\" === this.type() ? 'margin' : 'margin' + '-' + this.type();\n        var setmgn = {};\n        setmgn[mg] = this.value();\n        cmputl.rstyle(tgt, setmgn);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * margin type setter/getter\n     *\n     * @param (string) margin type ('top', 'right', 'bottom', 'left')\n     *                 undefined: call as getter\n     * @return (string) margin type\n     * @attention it's enable for all directions of margin if the type is null.\n     * @type parameter\n     */\n\n  }, {\n    key: \"type\",\n    value: function type(prm) {\n      try {\n        return this.confmng('type', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * margin size value setter/getter\n     *\n     * @param (string(size)) margin size\n     *                       undefined: call as getter\n     * @return (string(size)) margin size\n     * @type parameter\n     */\n\n  }, {\n    key: \"value\",\n    value: function value(prm) {\n      try {\n        return this.confmng('value', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron[\"class\"].Layout);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-margin/index.js?")},"./node_modules/mofron-util-transform/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-util-transform/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('/**\n * @file mofron-transform/index.js\n * @brief css transform util functions for mofron\n * @license MIT\n */\nmodule.exports = function (prm, x, y, z) {\n  try {\n    var set = function set(sx, sy, sz) {\n      try {\n        var set_val = null;\n\n        if (undefined !== sx && undefined !== sy && undefined !== sz) {\n          set_val = "translate3d(" + sx + "," + sy + "," + sz + ")";\n        }\n\n        if (undefined !== sx && undefined !== sy) {\n          set_val = "translate(" + sx + "," + sy + ")";\n        } else if (undefined !== sx) {\n          set_val = "translateX(" + sx + ")";\n        } else if (undefined !== sy) {\n          set_val = "translateY(" + sy + ")";\n        } else {\n          set_val = "translateZ(" + sz + ")";\n        }\n\n        prm.style({\n          "transform": set_val\n        }, {\n          bpref: true\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    };\n\n    var get = function get(gprm) {\n      try {\n        if (-1 !== gprm.indexOf("translate3d")) {\n          return gprm.substring("translate3d".length - 1, gprm.length - 1).split(\',\');\n        } else if (-1 === gprm.indexOf("translate")) {\n          return [undefined, undefined, undefined];\n        }\n\n        var sp_prm = gprm.split("translate")[1];\n\n        if (\'X\' === sp_prm[0]) {\n          return [sp_prm.substring(2, sp_prm.length - 1), undefined, undefined];\n        } else if (\'Y\' === sp_prm[0]) {\n          return [undefined, sp_prm.substring(2, sp_prm.length - 1), undefined];\n        } else if (\'Z\' === sp_prm[0]) {\n          return [undefined, undefined, sp_prm.substring(2, sp_prm.length - 1)];\n        }\n\n        var ret = gprm.substring("translate".length - 1, gprm.length - 1).split(\',\');\n        ret.push(undefined);\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    };\n\n    var trans = prm.style("transform");\n\n    if (null === trans) {\n      set(x, y, z);\n      return;\n    }\n\n    var trans_val = get(trans);\n    /* set translate */\n\n    set(undefined !== x ? x : trans_val[0], undefined !== y ? y : trans_val[1], undefined !== z ? z : trans_val[2]);\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-util-transform/index.js?')},"./node_modules/mofron/index.js":
/*!**************************************!*\
  !*** ./node_modules/mofron/index.js ***!
  \**************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('__webpack_require__(/*! expose-loader?exposes[]=mofron!./src/core/namesp.js */ "./node_modules/expose-loader/dist/cjs.js?exposes[]=mofron!./node_modules/mofron/src/core/namesp-exposed.js");\n/* util functions */\n\n\n__webpack_require__(/*! ./src/util/common.js */ "./node_modules/mofron/src/util/common.js");\n\n__webpack_require__(/*! ./src/util/component.js */ "./node_modules/mofron/src/util/component.js");\n\n__webpack_require__(/*! ./src/util/effect.js */ "./node_modules/mofron/src/util/effect.js");\n\nmofron["class"].ConfArg = __webpack_require__(/*! ./src/type/ConfArg.js */ "./node_modules/mofron/src/type/ConfArg.js");\nmofron["class"].PullConf = __webpack_require__(/*! ./src/type/PullConf.js */ "./node_modules/mofron/src/type/PullConf.js");\nmofron["class"].Dom = __webpack_require__(/*! ./src/core/dom/Dom.js */ "./node_modules/mofron/src/core/dom/Dom.js");\nmofron["class"].Component = __webpack_require__(/*! ./src/tag/Component.js */ "./node_modules/mofron/src/tag/Component.js");\nmofron["class"].Layout = __webpack_require__(/*! ./src/tag/Layout.js */ "./node_modules/mofron/src/tag/Layout.js");\nmofron["class"].Effect = __webpack_require__(/*! ./src/tag/Effect.js */ "./node_modules/mofron/src/tag/Effect.js");\nmofron["class"].Event = __webpack_require__(/*! ./src/tag/Event.js */ "./node_modules/mofron/src/tag/Event.js");\nmofron["class"].Color = __webpack_require__(/*! ./src/type/Color.js */ "./node_modules/mofron/src/type/Color.js");\nmofron["class"].Size = __webpack_require__(/*! ./src/type/size/Size.js */ "./node_modules/mofron/src/type/size/Size.js");\nmofron["class"].Pixel = __webpack_require__(/*! ./src/type/size/Pixel.js */ "./node_modules/mofron/src/type/size/Pixel.js");\nmofron["class"].Rem = __webpack_require__(/*! ./src/type/size/Rem.js */ "./node_modules/mofron/src/type/size/Rem.js");\n\nvar Window = __webpack_require__(/*! ./src/core/Window.js */ "./node_modules/mofron/src/core/Window.js");\n\nmofron.window = new Window();\n\nvar Document = __webpack_require__(/*! ./src/core/Document.js */ "./node_modules/mofron/src/core/Document.js");\n\nmofron.document = new Document();\nmodule.exports = mofron;\n\n//# sourceURL=webpack:///./node_modules/mofron/index.js?')},"./node_modules/mofron/src/core/Base.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/src/core/Base.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @file  Base.js\n * @brief basement class of mofron\n * @author simpart\n */\nvar comutl = mofron.util.common;\n\nvar ConfManager = __webpack_require__(/*! ./ConfManager.js */ "./node_modules/mofron/src/core/ConfManager.js");\n\nvar genid = function genid() {\n  try {\n    var ret_id = \'_\' + new Date().getTime() + \'-\';\n    var loop = 0;\n    var val = 0;\n\n    for (loop = 0; loop < 8; loop++) {\n      val = Math.random() * 16 | 0;\n      ret_id += (loop == 12 ? 4 : loop == 16 ? val & 3 | 8 : val).toString(16);\n    }\n\n    return ret_id;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  function _class() {\n    _classCallCheck(this, _class);\n\n    try {\n      this.m_confmng = new ConfManager();\n      /* init config */\n\n      this.confmng().add("name", {\n        type: "string",\n        target: "private"\n      });\n      this.confmng().add("modname", {\n        type: "string",\n        target: "private",\n        list: true\n      });\n      this.confmng().add("id", {\n        type: "string",\n        target: "private",\n        init: genid()\n      });\n      this.confmng().add("data", {\n        type: "key-value",\n        target: "private"\n      });\n      this.confmng().add("shortForm", {\n        type: "array",\n        target: "private",\n        init: []\n      });\n      this.modname("Base");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n  /**\n   * config manager\n   * \n   * @param (string) config key\n   * @param (mixed) config data\n   * @param (mixed) config data2\n   * @return (mixed) config data\n   */\n\n\n  _createClass(_class, [{\n    key: "confmng",\n    value: function confmng(key, val, val2) {\n      try {\n        if (undefined === key) {\n          return this.m_confmng;\n        }\n\n        return this.m_confmng.conf(key, val, val2);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * object name setter/getter\n     * \n     * @param (string) object name\n     * @return (string) object name\n     */\n\n  }, {\n    key: "name",\n    value: function name(key) {\n      try {\n        if (undefined !== key) {\n          mofron.objkey[key] = this;\n        }\n\n        return this.confmng("name", key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * module name setter / getter\n     *\n     * @param (string) module name\n     * @return (string) module name\n     */\n\n  }, {\n    key: "modname",\n    value: function modname(prm) {\n      try {\n        var ret = this.confmng("modname", prm);\n        return undefined !== ret ? ret[ret.length - 1] : ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * module id getter\n     * \n     * @return (string) module id\n     */\n\n  }, {\n    key: "id",\n    value: function id() {\n      try {\n        return this.confmng().get("id");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * data buffer\n     * \n     * @param (string) buffer key\n     * @param (mixed) buffer data\n     *                undefined: call as getter\n     * @return (mixed) buffer data\n     */\n\n  }, {\n    key: "data",\n    value: function data(key, val) {\n      try {\n        if ("string" !== typeof key) {\n          throw new Error("invalid parameter");\n        }\n\n        var dat = this.confmng().get("data");\n\n        if (undefined === val) {\n          /* getter */\n          return undefined === dat[key] ? null : dat[key];\n        }\n        /* setter */\n\n\n        dat[key] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * short form parameter setter/getter\n     * \n     * @param (string) \n     */\n\n  }, {\n    key: "shortForm",\n    value: function shortForm() {\n      try {\n        if (0 === arguments.length) {\n          return this.confmng().get("shortForm");\n        }\n\n        var val = [];\n\n        for (var aidx in arguments) {\n          val.push(arguments[aidx]);\n        }\n\n        this.confmng("shortForm", val);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * execute config\n     * \n     * @param (mixed) config data\n     * @return (mixed) config list\n     */\n\n  }, {\n    key: "config",\n    value: function config() {\n      try {\n        /* get argument */\n        if (0 === arguments.length) {\n          /* getter */\n          return this.confmng().get();\n        }\n\n        var arg = new mofron["class"].ConfArg();\n        arg.param(arguments);\n        /* setter */\n\n        if (1 === arguments.length && comutl.isinc(arguments[0], "ConfArg")) {\n          arguments[0].exec(this, this.shortForm());\n        } else if (1 < arg.param().length || !("object" === _typeof(arguments[0]) && false === Array.isArray(arguments[0]) && false === comutl.isinc(arguments[0], "Base"))) {\n          /* short form */\n          arg.exec(this, this.shortForm());\n        } else {\n          /* config */\n          for (var cf_idx in arguments[0]) {\n            if ("function" !== typeof this[cf_idx]) {\n              console.warn("invalid function: " + cf_idx);\n              continue;\n            }\n\n            if (true !== comutl.isinc(arguments[0][cf_idx], "ConfArg")) {\n              this[cf_idx](arguments[0][cf_idx]);\n            } else {\n              arguments[0][cf_idx].exec(this, cf_idx);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}();\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Base.js?')},"./node_modules/mofron/src/core/ConfManager.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron/src/core/ConfManager.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @file ConfManager.js\n * @brief config manager for mofron modules. it suply accessor functions to object.\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function () {\n  function _class() {\n    _classCallCheck(this, _class);\n\n    try {\n      this.m_conf = {};\n      this.m_opt = {};\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  _createClass(_class, [{\n    key: "conf",\n    value: function conf(key, val, val2) {\n      try {\n        if ("string" !== typeof key) {\n          throw new Error("invalid parameter");\n        }\n\n        return undefined === val ? this.get(key) : this.set(key, val, val2);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "add",\n    value: function add(key, opt) {\n      try {\n        if ("object" !== _typeof(opt) || true === Array.isArray(opt) || true === comutl.isinc(opt, "Base")) {\n          throw new Error("invalid parameter");\n        }\n\n        this.m_opt[key] = opt;\n\n        if ("key-value" === opt.type) {\n          this.m_conf[key] = {};\n          return;\n        } else if (true === opt.list) {\n          this.m_conf[key] = [];\n          return;\n        }\n\n        if (undefined !== opt.init) {\n          this.set(key, opt.init);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "get",\n    value: function get(key) {\n      try {\n        if (undefined === key) {\n          /* get all config */\n          var ret = {};\n\n          for (var cidx in this.m_conf) {\n            if ("private" === this.m_opt[cidx].target) {\n              continue;\n            }\n\n            ret[cidx] = this.m_conf[cidx];\n          }\n\n          return ret;\n        } else if ("string" !== typeof key) {\n          throw new Error("invalid parameter");\n        }\n        /* return config */\n\n\n        return undefined !== this.m_conf[key] ? this.m_conf[key] : null;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "chkValue",\n    value: function chkValue(key, val, val2) {\n      try {\n        var opt = this.m_opt[key];\n\n        if (undefined === opt || undefined === opt.type) {\n          throw new Error("could not find :" + key);\n        }\n\n        if ("color" === opt.type) {\n          var clr = comutl.getcolor(val);\n          return null === clr ? clr : clr.toString();\n        } else if ("size" === opt.type) {\n          comutl.getsize(val);\n          return val;\n        } else if ("event" === opt.type) {\n          if ("function" !== typeof val) {\n            throw new Error(\'invalid parameter\');\n          }\n\n          return [val, val2];\n        } else if ("array" === opt.type) {\n          if (false === Array.isArray(val)) {\n            throw new Error(\'invalid parameter\');\n          }\n        } else if ("key-value" === opt.type) {\n          if ("object" !== _typeof(val) || true === Array.isArray(val) || true === comutl.isinc(val, "Base")) {\n            throw new Error(\'invalid parameter\');\n          }\n        } else if (true === comutl.isinc(val, \'Base\')) {\n          if (false === comutl.isinc(val, opt.type)) {\n            throw new Error(\'invalid parameter\');\n          }\n        } else if (opt.type !== _typeof(val)) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        return val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "set",\n    value: function set(key, val, val2) {\n      try {\n        if ("string" !== typeof key || undefined === this.m_opt[key]) {\n          throw new Error("invalid parameter");\n        }\n\n        if (true === this.m_opt[key].list && true === Array.isArray(val) && "array" !== this.m_opt[key].type) {\n          for (var vidx in val) {\n            this.set(key, val[vidx]);\n          }\n\n          return;\n        }\n\n        var set_val = this.chkValue(key, val, val2);\n\n        if (true === this.m_opt[key].list) {\n          this.m_conf[key].push(set_val);\n        } else if ("key-value" === this.m_opt[key].type) {\n          for (var _vidx in val) {\n            this.m_conf[key][_vidx] = val[_vidx];\n          }\n        } else {\n          if (true === Array.isArray(this.m_opt[key].select)) {\n            var exs = false;\n\n            for (var sidx in this.m_opt[key].select) {\n              if (set_val === this.m_opt[key].select[sidx]) {\n                exs = true;\n                break;\n              }\n            }\n\n            if (false === exs) {\n              throw new Error("invald parameter");\n            }\n          }\n\n          this.m_conf[key] = set_val;\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "delete",\n    value: function _delete(key) {\n      try {\n        if ("string" !== typeof key) {\n          throw new Error("invalid parameter");\n        }\n\n        delete this.m_conf[key];\n        this.add(key, this.m_opt[key]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}();\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/ConfManager.js?')},"./node_modules/mofron/src/core/Document.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/core/Document.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Window.js\n * @brief mofron window class\n */\nvar Base = __webpack_require__(/*! ./Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar comutl = __webpack_require__(/*! ./../util/common.js */ "./node_modules/mofron/src/util/common.js");\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Document\');\n\n      _this.confmng().add("event", {\n        type: "Event",\n        list: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "getRawDom",\n    value: function getRawDom() {\n      return document;\n    }\n  }, {\n    key: "event",\n    value: function event(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return this.confmng("event");\n        }\n        /* setter */\n\n\n        this.confmng("event", prm); //prm.component(this);\n\n        prm.contents(this);\n        prm.isInited(true);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Document.js?')},"./node_modules/mofron/src/core/ModConf.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/core/ModConf.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file ModConf.js\n * @brief module config interface for mofron component\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ./Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  function _class(po) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, po);\n\n      _this.modname(\'ModConf\');\n      /* init config */\n\n\n      _this.confmng().add("component", {\n        type: "Component"\n      });\n\n      _this.confmng().add("tag", {\n        type: "string"\n      });\n\n      _this.confmng().add("isInited", {\n        type: "boolean",\n        init: false\n      });\n\n      _this.confmng().add("suspend", {\n        type: "boolean",\n        init: false\n      });\n\n      _this.confmng().add("innerTgt", {\n        type: "boolean",\n        init: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "component",\n    value: function component(prm) {\n      try {\n        return this.confmng("component", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "execute",\n    value: function execute() {\n      console.warn(\'not implement\');\n    }\n  }, {\n    key: "contents",\n    value: function contents(p1) {\n      console.warn(\'not implement\');\n    }\n  }, {\n    key: "tag",\n    value: function tag(prm) {\n      try {\n        return this.confmng("tag", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isInited",\n    value: function isInited(prm) {\n      try {\n        return this.confmng("isInited", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "suspend",\n    value: function suspend(prm) {\n      try {\n        return this.confmng("suspend", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "innerTgt",\n    value: function innerTgt(prm) {\n      try {\n        return this.confmng("innerTgt", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/ModConf.js?')},"./node_modules/mofron/src/core/Window.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/core/Window.js ***!
  \************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Window.js\n * @brief mofron window class\n */\n//const Base   = require("./Base.js");\n//const Component = require("../tag/Component.js");\nvar comutl = __webpack_require__(/*! ./../util/common.js */ "./node_modules/mofron/src/util/common.js");\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Window\');\n\n      _this.confmng().add("landscapeEvent", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("portraitEvent", {\n        type: "event",\n        list: true\n      }); //this.confmng().add("event", { type: "Event", list: true });\n\n\n      _this.initOrientation();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "isPortrait",\n    value: function isPortrait() {\n      try {\n        return window.innerHeight > window.innerWidth ? true : false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isLandscape",\n    value: function isLandscape() {\n      try {\n        return window.innerHeight < window.innerWidth ? true : false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "resizeEvent",\n    value: function resizeEvent(func, prm, tlag) {\n      try {\n        var que_buf = null;\n        var param = prm;\n        var time_lag = undefined === tlag ? 200 : tlag;\n\n        if (\'function\' !== typeof func || \'number\' !== typeof time_lag) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        window.addEventListener(\'resize\', function () {\n          try {\n            clearTimeout(que_buf);\n            que_buf = setTimeout(func, time_lag, param);\n          } catch (e) {\n            console.error(e.stack);\n            throw new Error();\n          }\n        }, false);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "initOrientation",\n    value: function initOrientation() {\n      try {\n        if (undefined !== screen.orientation && null === screen.orientation.onchange) {\n          screen.orientation.onchange = this.orientationHandler;\n        } else if (null === screen.onmozorientationchange) {\n          screen.onmozorientationchange = this.orientationHandler;\n        } else if (null === screen.onmsorientationchange) {\n          screen.onmsorientationchange = this.orientationHandler;\n        } else {\n          window.addEventListener("orientationchange", this.orientationHandler);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "orientationHandler",\n    value: function orientationHandler(evt) {\n      try {\n        var ef = null;\n\n        if ("landscape-primary" === screen.mozOrientation || "landscape-secondary" === screen.mozOrientation || "landscape-primary" === screen.orientation.type || "landscape-secondary" === screen.orientation.type) {\n          /* landscape event */\n          if ("function" === typeof this["landscapeEvent"]) {\n            ef = this.landscapeEvent();\n          }\n        } else if ("portrait-primary" === screen.mozOrientation || "portrait-secondary" === screen.mozOrientation || "portrait-primary" === screen.orientation.type || "portrait-secondary" === screen.orientation.type) {\n          /* vertical event */\n          if ("function" === typeof this["portraitEvent"]) {\n            ef = this.portraitEvent();\n          }\n        } else {\n          if (window.innerHeight < window.innerWidth) {\n            /* landscape event */\n            if ("function" === typeof this["landscapeEvent"]) {\n              ef = this.landscapeEvent();\n            }\n          } else {\n            /* portrait event */\n            if ("function" === typeof this["portraitEvent"]) {\n              ef = this.portraitEvent();\n            }\n          }\n        }\n\n        for (var eidx in ef) {\n          ef[eidx].exec(this, evt);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "landscapeEvent",\n    value: function landscapeEvent(fnc, prm) {\n      try {\n        return this.confmng("landscapeEvent", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "portraitEvent",\n    value: function portraitEvent(fnc, prm) {\n      try {\n        return this.confmng("portraitEvent", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "eventDom",\n    value: function eventDom() {\n      return this;\n    }\n  }, {\n    key: "getRawDom",\n    value: function getRawDom() {\n      return window;\n    }\n  }, {\n    key: "event",\n    value: function event(prm) {\n      try {\n        var ret = _get(_getPrototypeOf(_class.prototype), "event", this).call(this, prm);\n\n        if (undefined === prm) {\n          return ret;\n        }\n\n        if (true === comutl.isinc(prm, "Event")) {\n          prm.execute();\n        } else if (true === Array.isArray(prm)) {\n          for (var pidx in prm) {\n            prm[pidx].execute();\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Window.js?')},"./node_modules/mofron/src/core/dom/Attrs.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Attrs.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Attrs.js\n * @author simpart\n */\nvar DomConf = __webpack_require__(/*! ./DomConf.js */ "./node_modules/mofron/src/core/dom/DomConf.js");\n\nmodule.exports = /*#__PURE__*/function (_DomConf) {\n  _inherits(_class, _DomConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target adom object\n   */\n  function _class(tgt) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, tgt);\n\n      _this.modname(\'Attrs\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * set style\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n\n\n  _createClass(_class, [{\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        this.dom().getRawDom().setAttribute(key, val);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        this.dom().getRawDom().removeAttribute(key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get attribute value from rawdom\n     *\n     * @param key : (string) style key\n     * @return (object) style contents\n     * @return (string) style contents value\n     */\n\n  }, {\n    key: "domGet",\n    value: function domGet(key) {\n      try {\n        return this.dom().getRawDom().getAttribute(key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        var ret = \'\';\n        var conts = this.get();\n\n        for (var cidx in conts) {\n          ret += null === conts[cidx] ? cidx : cidx + \'="\' + conts[cidx] + \'"\';\n          ret += " ";\n        }\n\n        return "" === ret ? "" : ret.substring(0, ret.length - 1);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(DomConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Attrs.js?')},"./node_modules/mofron/src/core/dom/Class.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Class.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Class.js\n * @author simpart\n */\nvar DomConf = __webpack_require__(/*! ./DomConf.js */ "./node_modules/mofron/src/core/dom/DomConf.js");\n\nmodule.exports = /*#__PURE__*/function (_DomConf) {\n  _inherits(_class, _DomConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target adom object\n   */\n  function _class(tgt) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, tgt);\n\n      _this.modname(\'Class\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "set",\n    value: function set(prm, opt) {\n      try {\n        if (!("string" === typeof prm || true === Array.isArray(prm))) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        var set_prm = {};\n\n        if ("string" === typeof prm) {\n          set_prm[prm] = "";\n        } else {\n          for (var pidx in prm) {\n            if ("string" !== typeof prm[pidx]) {\n              throw new Error("invalid parameter");\n            }\n\n            set_prm[prm[pidx]] = "";\n          }\n        }\n\n        _get(_getPrototypeOf(_class.prototype), "set", this).call(this, set_prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "get",\n    value: function get() {\n      try {\n        var ret = [];\n\n        var cls = _get(_getPrototypeOf(_class.prototype), "get", this).call(this);\n\n        for (var cidx in cls) {\n          ret.push(cidx);\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set class name to rowdom\n     *\n     * @param key : (string) style key\n     * @param val : (string) style value\n     */\n\n  }, {\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        this.dom().getRawDom().classList.add(key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        this.dom().getRawDom().classList.remove(key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get class name from rawdom\n     *\n     * @return (object) style contents\n     * @return (string) style contents value\n     */\n\n  }, {\n    key: "domGet",\n    value: function domGet() {\n      try {\n        var clnm = this.dom().getRawDom().className;\n\n        if (undefined === clnm || null === clnm || \'\' === clnm) {\n          return null;\n        }\n\n        return clnm.split(\' \');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        var ret = \'\';\n        var conts = this.get();\n\n        for (var idx in conts) {\n          ret += conts[idx] + " ";\n        }\n\n        return \'\' === ret ? \'\' : \'class="\' + ret.substring(0, ret.length - 1) + \'"\';\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(DomConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Class.js?')},"./node_modules/mofron/src/core/dom/Dom.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Dom.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Dom.js\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar Class = __webpack_require__(/*! ./Class.js */ "./node_modules/mofron/src/core/dom/Class.js");\n\nvar Style = __webpack_require__(/*! ./Style.js */ "./node_modules/mofron/src/core/dom/Style.js");\n\nvar Attrs = __webpack_require__(/*! ./Attrs.js */ "./node_modules/mofron/src/core/dom/Attrs.js");\n\nvar Props = __webpack_require__(/*! ./Props.js */ "./node_modules/mofron/src/core/dom/Props.js");\n\nvar Tree = __webpack_require__(/*! ../tree/Tree.js */ "./node_modules/mofron/src/core/tree/Tree.js");\n\nvar IDX_CLASS = 0;\nvar IDX_STYLE = 1;\nvar IDX_ATTRS = 2;\nvar IDX_PROPS = 3;\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   */\n  function _class(tc, cmp) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Dom\');\n\n      _this.confmng().add("tag", {\n        type: "string"\n      });\n\n      _this.confmng().add("component", {\n        type: "Component"\n      });\n\n      _this.confmng().add("text", {\n        type: "string",\n        init: ""\n      });\n\n      _this.confmng().add("dummy", {\n        type: "boolean",\n        init: false\n      });\n\n      _this.m_tree = new Tree(_assertThisInitialized(_this));\n      _this.m_rawdom = null;\n      _this.m_conf = [new Class(_assertThisInitialized(_this)), new Style(_assertThisInitialized(_this)), new Attrs(_assertThisInitialized(_this)), new Props(_assertThisInitialized(_this))];\n\n      if ("string" === typeof tc) {\n        _this.tag(tc);\n\n        _this.component(cmp);\n      } else if (undefined !== tc) {\n        _this.config(tc);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * tag name setter / getter\n   *\n   * @param tg : (string) tag name (option)\n   * @return (string) tag name\n   */\n\n\n  _createClass(_class, [{\n    key: "tag",\n    value: function tag(tg) {\n      try {\n        return this.confmng("tag", tg);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * component getter / setter\n     * \n     * @param cmp (object) mofron.Component\n     * @return (object) mofron.Component\n     */\n\n  }, {\n    key: "component",\n    value: function component(cmp) {\n      try {\n        return this.confmng("component", cmp);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "getTree",\n    value: function getTree() {\n      try {\n        return this.m_tree;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "child",\n    value: function child(chd, idx) {\n      try {\n        if (undefined === chd) {\n          /* getter */\n          return this.m_tree.getChild();\n        }\n        /* setter */\n\n\n        this.m_tree.addChild(chd, idx);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "parent",\n    value: function parent(prm) {\n      try {\n        return this.m_tree.parent(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "conf",\n    value: function conf(kv, opt, idx) {\n      try {\n        var cnf = this.m_conf[idx];\n\n        if (undefined === kv) {\n          /* get style object */\n          return cnf;\n        } else if (\'string\' === typeof kv) {\n          /* get style value of the key */\n          return cnf.get(kv);\n        }\n        /* setter */\n\n\n        cnf.set(kv, opt);\n        this.value(null);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * style setter / getter\n     *\n     * @param kv : (object) key-value object\n     * @param opt: (object) option\n     * @return (string) : value of style\n     * @return (object) : style object\n     */\n\n  }, {\n    key: "style",\n    value: function style(kv, opt) {\n      try {\n        if (undefined !== opt && true === opt.bpref) {\n          for (var key in kv) {\n            kv["webkit-" + key] = kv[key];\n            kv["-moz-" + key] = kv[key];\n            kv["-o-" + key] = kv[key];\n            kv["-ms-" + key] = kv[key];\n          }\n        }\n\n        return this.conf(kv, opt, IDX_STYLE);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * tag attribute setter / getter\n     *\n     * @param kv  : (object/string) key-value object / key of attribute\n     * @param val : (object) value of attribute\n     * @return\n     */\n\n  }, {\n    key: "attrs",\n    value: function attrs(kv, opt) {\n      try {\n        return this.conf(kv, opt, IDX_ATTRS);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * dom property setter / getter\n     * \n     * @param kv  : (object/string) key-value object / key of\n     * @param val : (object)  value of property\n     */\n\n  }, {\n    key: "props",\n    value: function props(kv, opt) {\n      try {\n        return this.conf(kv, opt, IDX_PROPS);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * tag class name setter / getter\n     * \n     * @param name : (string) class name\n     */\n\n  }, {\n    key: "class",\n    value: function _class(prm, opt) {\n      try {\n        if (undefined === prm) {\n          return this.conf(undefined === opt ? undefined : "class", opt, IDX_CLASS);\n        }\n\n        this.conf("string" === typeof prm ? [prm] : prm, opt, IDX_CLASS);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * tag contents text setter / getter\n     * \n     * @param cnt : (string) tag contents (option)\n     * @return (string) tag contents\n     */\n\n  }, {\n    key: "text",\n    value: function text(prm) {\n      try {\n        var ret = this.confmng("text", prm);\n\n        if (undefined !== prm && true === this.isPushed()) {\n          this.getRawDom().innerHTML = prm;\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * dom string getter\n     *\n     * @return (string) dom string\n     */\n\n  }, {\n    key: "value",\n    value: function value() {\n      try {\n        var chd = this.child();\n        var chd_ret = \'\';\n\n        for (var cidx in chd) {\n          chd_ret += chd[cidx].value();\n        }\n\n        if (true === this.dummy()) {\n          return chd_ret;\n        }\n\n        var ret = \'<\' + this.tag() + \' \';\n        /* set id attribute */\n\n        ret += \'id="\' + this.id() + \'" \';\n        /* set dom config */\n\n        var cnf = this.m_conf;\n        var cnf_val = null;\n\n        for (var idx in cnf) {\n          var _cnf_val = cnf[idx].toString();\n\n          if ("" !== _cnf_val) {\n            ret += _cnf_val + " ";\n          }\n        }\n\n        ret += \'>\';\n        /* set tag contents */\n\n        ret += this.text();\n        /* check single */\n\n        if (true === is_single(this.tag())) {\n          return ret;\n        }\n        /* set child value */\n\n\n        ret += chd_ret;\n        return ret + \'</\' + this.tag() + \'>\';\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * draw dom to target dom\n     * \n     * @param (key-value) push option\n     *     target   : push target object\n     *     child    : child flag\n     *     position : position of insertAdjacentHTML parameter\n     */\n\n  }, {\n    key: "push",\n    value: function push(opt) {\n      try {\n        if (true === mofron.ssr) {\n          return;\n        } else if (undefined === opt) {\n          throw new Error("invalid parameter");\n        }\n\n        if (true !== opt.child) {\n          opt.target.insertAdjacentHTML(undefined === opt.position ? \'beforeend\' : opt.position, this.value());\n        }\n\n        var props = this.props().get();\n\n        if (true === this.dummy()) {\n          this.m_rawdom = null !== this.parent() ? this.parent().getRawDom() : null;\n        } else {\n          if (null !== this.parent()) {\n            this.m_rawdom = this.parent().getRawDom().querySelector("#" + this.id());\n          } else {\n            this.m_rawdom = document.body.querySelector("#" + this.id());\n          }\n        }\n\n        this.props(props); // set property\n\n        /* notify push to children */\n\n        var chd = this.child();\n\n        for (var cidx in chd) {\n          chd[cidx].push({\n            target: this.m_rawdom,\n            child: true\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get adom status\n     *\n     * @return (boolean) true : this adom had pushed\n     * @return (boolean) false : this adom had not pushed\n     */\n\n  }, {\n    key: "isPushed",\n    value: function isPushed() {\n      try {\n        return null === this.m_rawdom ? false : true;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get pushed dom object from blowser\n     *\n     * @return (object) raw dom object\n     */\n\n  }, {\n    key: "getRawDom",\n    value: function getRawDom() {\n      try {\n        if (false === this.isPushed()) {\n          throw new Error(\'this dom is not pushed yet\');\n        }\n\n        return this.m_rawdom;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      try {\n        /* remove this object from parent dom */\n        if (true === this.isPushed()) {\n          this.getRawDom().remove();\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "dummy",\n    value: function dummy(prm) {\n      try {\n        return this.confmng("dummy", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n\nvar is_single = function is_single(prm) {\n  try {\n    if ("br" === prm || "hr" === prm || "input" === prm || "img" === prm) {\n      return true;\n    }\n\n    return false;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Dom.js?')},"./node_modules/mofron/src/core/dom/DomConf.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/DomConf.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file DomConf.js\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  function _class(dom) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("DomConf");\n\n      _this.confmng().add("lock", {\n        type: "key-value"\n      });\n\n      _this.confmng().add("dom", {\n        type: "Dom"\n      });\n\n      _this.confmng().add("listener", {\n        type: "array",\n        list: true\n      });\n\n      _this.dom(dom);\n\n      _this.m_conts = {};\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "dom",\n    value: function dom(prm) {\n      try {\n        return this.confmng("dom", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "lock",\n    value: function lock(key, val) {\n      try {\n        var lock = this.confmng().get("lock");\n\n        if (undefined === val) {\n          /* getter */\n          return undefined === lock[key] ? false : lock[key];\n        }\n        /* setter */\n\n\n        if ("boolean" !== typeof val) {\n          throw new Error("invalid parameter");\n        }\n\n        lock[key] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "chkval",\n    value: function chkval(kv) {\n      try {\n        if (!("object" === _typeof(kv) && false === Array.isArray(kv) && false === comutl.isinc(kv, "Base"))) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        for (var key in kv) {\n          if (null !== kv[key] && "object" === _typeof(kv[key])) {\n            throw new Error("invalid parameter");\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "set",\n    value: function set(kv, opt) {\n      try {\n        this.chkval(kv);\n        var p_opt = undefined === opt ? {} : opt;\n        var lis = [];\n\n        for (var key in kv) {\n          var old_kv = {};\n          var new_kv = {};\n          old_kv[key] = undefined === this.m_conts[key] ? null : this.m_conts[key];\n          new_kv[key] = kv[key];\n\n          if (null === kv[key]) {\n            /* delete config */\n            this.rem(key);\n            lis = this.listener(key);\n\n            for (var lidx in lis) {\n              lis[lidx][0](this.dom(), [new_kv[key], old_kv[key]], lis[lidx][1]);\n            }\n\n            if (true === p_opt.lock) {\n              this.lock(key, true);\n            }\n\n            continue;\n          }\n          /* setter */\n\n\n          if (true === p_opt.passive) {\n            if (null === this.get(key)) {\n              this.m_conts[key] = kv[key];\n            } else {\n              continue;\n            }\n          } else if (true === p_opt.forced) {\n            this.m_conts[key] = kv[key];\n            this.lock(key, false);\n          } else {\n            if (true === this.lock(key)) {\n              continue;\n            }\n\n            this.m_conts[key] = kv[key];\n          }\n\n          if (true === p_opt.lock) {\n            this.lock(key, true);\n          }\n\n          if (true === this.dom().isPushed()) {\n            /* target dom is already rendered */\n            this.domSet(key, kv[key]);\n          }\n\n          lis = this.listener(key);\n\n          for (var lidx2 in lis) {\n            lis[lidx2][0](this.dom(), [new_kv[key], old_kv[key]], lis[lidx2][1]);\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "get",\n    value: function get(key) {\n      try {\n        if (false === this.dom().isPushed()) {\n          if (undefined === key) {\n            return this.m_conts;\n          }\n\n          return undefined === this.m_conts[key] ? null : this.m_conts[key];\n        } else {\n          /* target is already rendered */\n          return undefined == this.domGet(key) ? null : this.domGet(key);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "rem",\n    value: function rem(key) {\n      try {\n        if (undefined !== this.m_conts[key]) {\n          delete this.m_conts[key];\n        }\n\n        if (true === this.dom().isPushed()) {\n          /* target dom is already rendered */\n          this.domRem(key);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        console.warn(\'not implement\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        console.warn(\'not implement\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domGet",\n    value: function domGet(key) {\n      try {\n        console.warn(\'not implement\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "listener",\n    value: function listener(key, fnc, prm) {\n      try {\n        if (undefined === fnc) {\n          /* getter */\n          var lis = this.confmng("listener");\n\n          if (undefined === key) {\n            return lis;\n          }\n\n          var ret = [];\n\n          for (var lidx in lis) {\n            if (key === lis[lidx][0]) {\n              ret.push([lis[lidx][1], lis[lidx][2]]);\n            }\n          }\n\n          return ret;\n        }\n\n        if ("string" !== typeof key || "function" !== typeof fnc) {\n          throw new Error("invalid parameter");\n        }\n\n        this.confmng("listener", [key, fnc, prm]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/DomConf.js?')},"./node_modules/mofron/src/core/dom/Props.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Props.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Props.js\n * @author simpart\n */\nvar DomConf = __webpack_require__(/*! ./DomConf.js */ "./node_modules/mofron/src/core/dom/DomConf.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_DomConf) {\n  _inherits(_class, _DomConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target dom object\n   */\n  function _class(tgt) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, tgt);\n\n      _this.modname(\'Prop\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "chkval",\n    value: function chkval(kv) {\n      try {\n        if (!("object" === _typeof(kv) && false === Array.isArray(kv) && false === comutl.isinc(kv, "Base"))) {\n          throw new Error(\'invalid parameter\');\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set property\n     *\n     * @param key : (string) property key\n     * @param val : (string) property value\n     */\n\n  }, {\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        if (undefined === this.dom().getRawDom()[key]) {\n          throw new Error(key + \' is unknown property\');\n        }\n\n        this.dom().getRawDom()[key] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        if (undefined === this.dom().getRawDom()[key]) {\n          return;\n        }\n\n        delete this.dom().getRawDom()[key];\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get property value from rawdom\n     *\n     * @param key : (string) property key\n     * @return (string) property value\n     */\n\n  }, {\n    key: "domGet",\n    value: function domGet(key) {\n      try {\n        var ret = this.dom().getRawDom()[key];\n        return "" === ret ? undefined : ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        return "";\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(DomConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Props.js?')},"./node_modules/mofron/src/core/dom/Style.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Style.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Style.js\n * @author simpart\n */\nvar DomConf = __webpack_require__(/*! ./DomConf.js */ "./node_modules/mofron/src/core/dom/DomConf.js");\n\nmodule.exports = /*#__PURE__*/function (_DomConf) {\n  _inherits(_class, _DomConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   */\n  function _class(tgt) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, tgt);\n\n      _this.modname(\'Style\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * set style\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n\n\n  _createClass(_class, [{\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        this.dom().getRawDom().style[getcamel(key)] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get style value from rawdom\n     *\n     * @param key : (string) style key\n     * @return (object) style contents\n     * @return (string) style contents value\n     */\n\n  }, {\n    key: "domGet",\n    value: function domGet(key) {\n      try {\n        if (undefined === key) {\n          return this.dom().getRawDom().style;\n        }\n\n        var val = this.dom().getRawDom().style[getcamel(key)];\n        return undefined === val || "" === val ? null : val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        this.dom().getRawDom().style[getcamel(key)] = "";\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        var ret = \'\';\n        var conts = this.get();\n\n        for (var cidx in conts) {\n          ret += cidx + \':\' + conts[cidx] + \';\';\n        }\n\n        return \'\' === ret ? \'\' : \'style="\' + ret + \'"\';\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(DomConf);\n\nvar getcamel = function getcamel(prm) {\n  try {\n    if (\'string\' !== typeof prm) {\n      throw new Error(\'invalid parameter\');\n    }\n\n    if (prm.length - 1 === prm.lastIndexOf(\'-\')) {\n      throw new Error(\'invalid parameter\');\n    }\n\n    var skip = false;\n\n    if (0 === prm.indexOf(\'-\')) {\n      skip = true;\n    }\n\n    var ret_val = prm;\n    var ret_buf = null;\n    var up_str = null;\n    var idx = null;\n\n    while (true) {\n      idx = ret_val.indexOf(\'-\');\n\n      if (-1 === idx) {\n        break;\n      }\n\n      up_str = ret_val.charAt(idx + 1).toUpperCase();\n      ret_buf = ret_val.substr(0, idx);\n\n      if (true === skip) {\n        skip = false;\n        ret_val = ret_buf + ret_val.substr(idx + 1);\n      } else {\n        ret_val = ret_buf + up_str + ret_val.substr(idx + 2);\n      }\n    }\n\n    return ret_val;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Style.js?')},"./node_modules/mofron/src/core/tree/CompTree.js":
/*!*******************************************************!*\
  !*** ./node_modules/mofron/src/core/tree/CompTree.js ***!
  \*******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file CompTree.js\n * @brief tree manager for component\n * @license MIT\n */\nvar Tree = __webpack_require__(/*! ./Tree.js */ "./node_modules/mofron/src/core/tree/Tree.js");\n\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_Tree) {\n  _inherits(_class, _Tree);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    _classCallCheck(this, _class);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(_class, [{\n    key: "addChild",\n    value: function addChild(chd, idx) {\n      try {\n        if (true === Array.isArray(chd)) {\n          /* parameter check */\n          for (var cidx in chd) {\n            this.addChild(chd[cidx], idx);\n          }\n\n          return;\n        }\n        /* set parent-child relation in dom layer */\n\n\n        var rdom = chd.rootDom();\n\n        if (undefined === idx) {\n          this.target().childDom().child(rdom);\n        } else {\n          var tgt_tree = this.target().childDom().getTree();\n          var t_idx = tgt_tree.getIndex(this.target().child()[idx].rootDom()[0]);\n          tgt_tree.addChild(rdom, t_idx);\n        }\n        /* set parent-child relation in component layer */\n\n\n        _get(_getPrototypeOf(_class.prototype), "addChild", this).call(this, chd, idx);\n        /* check render */\n\n\n        if (true === this.target().isExists()) {\n          var layout = chd.layout();\n          /* layout */\n\n          for (var lidx in layout) {\n            lo[lo_idx].execute();\n          }\n          /* theme */\n\n\n          cmputl.theme(chd, this.target().theme());\n          /* render child */\n\n          cmputl.render(chd);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "replace",\n    value: function replace(o_chd, n_chd) {\n      try {\n        if (this.target().childDom().id() === o_chd.childDom().id()) {\n          /* old child is dom target, replace dom target */\n          this.target().childDom(n_chd.childDom());\n        }\n        /* set parent-child relation in component layer */\n\n\n        this.getChild().splice(this.getIndex(o_chd), 0, n_chd);\n        n_chd.parent(this.target());\n        /* set parent-child relation in dom layer */\n\n        var tgt_tree = o_chd.rootDom()[0].parent().getTree();\n        var rep_idx = tgt_tree.getIndex(o_chd.rootDom()[0]);\n        var n_rdom = n_chd.rootDom();\n\n        for (var ridx in n_rdom) {\n          tgt_tree.getChild().splice(rep_idx + parseInt(ridx), 0, n_rdom[ridx]);\n          n_rdom[ridx].parent(this.target().childDom());\n        }\n\n        if (true === o_chd.isExists()) {\n          cmputl.render(n_chd);\n        }\n\n        o_chd.destroy();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "delChild",\n    value: function delChild(chd) {\n      try {\n        /* release relational in dom layer */\n        var rdom = chd.rootDom();\n\n        for (var ridx in rdom) {\n          if (null !== rdom[ridx].parent()) {\n            rdom[ridx].parent().getTree().delChild(rdom[ridx]);\n          }\n        }\n        /* delete child component */\n\n\n        _get(_getPrototypeOf(_class.prototype), "delChild", this).call(this, chd);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Tree);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/tree/CompTree.js?')},"./node_modules/mofron/src/core/tree/Tree.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/tree/Tree.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports){eval('function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @file Tree.js\n * @brief basement tree manager\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function () {\n  function _class(tgt, elm) {\n    _classCallCheck(this, _class);\n\n    try {\n      this.m_parent = null;\n      this.m_child = [];\n      this.elemName(tgt.modname());\n      this.target(tgt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  _createClass(_class, [{\n    key: "elemName",\n    value: function elemName(prm) {\n      try {\n        if (undefined === prm) {\n          if (undefined === this.m_elemnm) {\n            throw new Error("could not find element name");\n          }\n\n          return this.m_elemnm;\n        }\n\n        if ("string" !== typeof prm) {\n          throw new Error("invalid parameter");\n        }\n\n        this.m_elemnm = prm;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "target",\n    value: function target(prm) {\n      try {\n        if (undefined === prm) {\n          if (undefined === this.m_target) {\n            throw new Error("could not find target");\n          }\n\n          return this.m_target;\n        }\n\n        if (false === comutl.isinc(prm, this.elemName())) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.m_target = prm;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "getChild",\n    value: function getChild() {\n      try {\n        return this.m_child;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "addChild",\n    value: function addChild(chd, idx) {\n      try {\n        /* parameter check */\n        if (true === Array.isArray(chd)) {\n          for (var cidx in chd) {\n            this.addChild(chd[cidx], undefined !== idx ? idx + parseInt(cidx) : undefined);\n          }\n\n          return;\n        }\n\n        if (false === comutl.isinc(chd, this.elemName())) {\n          throw new Error(\'invalid parameter\');\n        }\n        /* set parent-child relation */\n\n\n        chd.parent(this.target());\n        /* add child */\n\n        if (undefined === idx) {\n          this.getChild().push(chd);\n        } else {\n          this.getChild().splice(idx, 0, chd);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "delChild",\n    value: function delChild(chd) {\n      try {\n        var del_idx = this.getIndex(chd);\n        this.getChild().splice(del_idx, 1);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "parent",\n    value: function parent(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return undefined === this.m_parent ? null : this.m_parent;\n        }\n\n        if (false === comutl.isinc(prm, this.elemName())) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.m_parent = prm;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "getIndex",\n    value: function getIndex(prm) {\n      try {\n        var chd = this.getChild();\n\n        for (var cidx in chd) {\n          if (chd[cidx].id() === prm.id()) {\n            return parseInt(cidx);\n          }\n        }\n\n        throw new Error("invalid parameter");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}();\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/tree/Tree.js?')},"./node_modules/mofron/src/tag/Component.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/tag/Component.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   Component.js\n * @brief  basement component class\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../core/Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar CompTree = __webpack_require__(/*! ../core/tree/CompTree.js */ "./node_modules/mofron/src/core/tree/CompTree.js");\n\nvar Dom = mofron["class"].Dom;\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nvar effutl = __webpack_require__(/*! ../util/effect.js */ "./node_modules/mofron/src/util/effect.js");\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize property, dom\n   *\n   * @param (mixed) component proterty\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("Component");\n\n      _this.confmng().add("rootDom", {\n        type: "Dom",\n        list: true,\n        target: "private"\n      });\n\n      _this.confmng().add("childDom", {\n        type: "Dom",\n        target: "private"\n      });\n\n      _this.confmng().add("styleDom", {\n        type: "Dom",\n        target: "private"\n      });\n\n      _this.confmng().add("eventDom", {\n        type: "Dom",\n        target: "private"\n      });\n\n      _this.confmng().add("isConf", {\n        type: "boolean",\n        target: "private"\n      });\n\n      _this.confmng().add("layout", {\n        type: "ModConf",\n        list: true\n      });\n\n      _this.confmng().add("effect", {\n        type: "ModConf",\n        list: true\n      });\n\n      _this.confmng().add("event", {\n        type: "ModConf",\n        list: true\n      });\n\n      _this.confmng().add("style", {\n        type: "key-value"\n      });\n\n      _this.confmng().add("theme", {\n        type: "key-value"\n      });\n\n      _this.confmng().add("innerComp", {\n        type: "key-value",\n        target: "private"\n      });\n      /* initialize member */\n\n\n      _this.m_tree = new CompTree(_assertThisInitialized(_this));\n      /*** set config ***/\n\n      _this.shortForm("child");\n      /* user config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /*** dom method ***/\n\n  /**\n   * dom setter / getter\n   * \n   * @return (object) dom object\n   */\n\n\n  _createClass(_class, [{\n    key: "rootDom",\n    value: function rootDom(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          if (0 === this.confmng().get("rootDom").length) {\n            this.initDomConts();\n          }\n\n          return this.confmng().get("rootDom");\n        }\n        /* setter */\n\n\n        this.confmng().set("rootDom", prm);\n\n        if (null === this.childDom()) {\n          this.childDom(this.rootDom()[0]);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * dom target setter / getter\n     * \n     * @param tgt : (object) dom object\n     * @return (object) dom object\n     */\n\n  }, {\n    key: "childDom",\n    value: function childDom(tgt) {\n      try {\n        var ret = this.confmng("childDom", tgt);\n\n        if (null === ret) {\n          if (0 < this.rootDom().length) {\n            this.confmng("childDom", this.rootDom()[0]);\n            return this.confmng("childDom");\n          } else {\n            throw new Error("could not find child dom");\n          }\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get style target dom\n     *\n     * @param tgt : (object) dom object\n     * @return (object) dom object\n     */\n\n  }, {\n    key: "styleDom",\n    value: function styleDom(tgt) {\n      try {\n        var ret = this.confmng("styleDom", tgt);\n        return null === ret ? this.childDom() : ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get event target dom\n     *\n     * @param tgt : (object) dom object\n     * @return (object) dom object\n     */\n\n  }, {\n    key: "eventDom",\n    value: function eventDom(tgt) {\n      try {\n        var ret = this.confmng("eventDom", tgt);\n        return null === ret ? this.childDom() : ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "beforeRender",\n    value: function beforeRender() {\n      try {\n        cmputl.chdloop(this, "beforeRender");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "initDomConts",\n    value: function initDomConts(prm) {\n      try {\n        this.rootDom(new Dom(undefined === prm ? "div" : prm, this));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "afterRender",\n    value: function afterRender() {\n      try {\n        cmputl.chdloop(this, "afterRender");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "getTree",\n    value: function getTree() {\n      try {\n        return this.m_tree;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /*** child method ***/\n\n    /**\n     * child component setter / getter\n     * \n     * @param chd : (object) child component\n     * @param chd : (object) child component array\n     * @return (array) : childlen object\n     */\n\n  }, {\n    key: "child",\n    value: function child(chd, idx) {\n      try {\n        this.rootDom();\n        var ct = true === cmputl.isinncmp(this) ? this.childDom().component().getTree() : this.getTree();\n\n        if (undefined === chd) {\n          /* getter */\n          return ct.getChild();\n        }\n        /* setter */\n\n\n        ct.addChild(chd, idx);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "parent",\n    value: function parent(prm) {\n      try {\n        return this.getTree().parent(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "innerComp",\n    value: function innerComp(key, val, defcmp) {\n      try {\n        var incmp = this.confmng().get("innerComp");\n\n        if (undefined === val) {\n          /* getter */\n          if (undefined === incmp[key]) {\n            this[key](new defcmp());\n          }\n\n          return incmp[key];\n        } else if (false === comutl.iscmp(val)) {\n          throw new Error("invalid parameter");\n        }\n        /* setter */\n\n\n        if (undefined !== incmp[key]) {\n          if (false === comutl.isinc(val, incmp[key].modname())) {\n            throw new Error("invalid parameter");\n          }\n          /* rewrite component, replace target child */\n\n\n          var pnt = incmp[key].parent();\n\n          if (null !== pnt) {\n            pnt.getTree().replace(incmp[key], val);\n          }\n        }\n\n        incmp[key] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /* component method */\n\n    /**\n     * execute effect\n     *\n     * @param (number) execute id\n     * @param (function, array) callback\n     * @return (boolean) execute result\n     */\n\n  }, {\n    key: "execEffect",\n    value: function execEffect(eid, cb, cbp) {\n      try {\n        return effutl.exec(cmputl.modconf(this, cmputl.IDX_EFFECT), eid, [cb, cbp]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isExists",\n    value: function isExists() {\n      try {\n        return this.childDom().isPushed();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /*** user config method ***/\n\n    /**\n     * style getter / setter\n     *\n     * @return (object) style object\n     */\n\n  }, {\n    key: "style",\n    value: function style(kv, opt) {\n      try {\n        if ("string" === typeof kv) {\n          /* getter */\n          return this.styleDom().style(kv);\n        }\n\n        this.styleDom().style(kv, opt);\n\n        if (undefined === opt || true !== opt["private"]) {\n          this.confmng("style", kv);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "layout",\n    value: function layout(prm) {\n      try {\n        var ret = cmputl.modconf(this, 0, prm);\n\n        if (undefined !== prm && undefined !== ret) {\n          return true === Array.isArray(ret) && 1 === ret.length ? ret[0] : ret;\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "effect",\n    value: function effect(prm) {\n      try {\n        var ret = cmputl.modconf(this, 1, prm);\n\n        if (undefined !== prm && undefined !== ret) {\n          return true === Array.isArray(ret) && 1 === ret.length ? ret[0] : ret;\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "event",\n    value: function event(prm) {\n      try {\n        var ret = cmputl.modconf(this, 2, prm);\n\n        if (undefined !== prm && undefined !== ret) {\n          return true === Array.isArray(ret) && 1 === ret.length ? ret[0] : ret;\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "accessConf",\n    value: function accessConf() {\n      try {\n        var hit = false;\n\n        for (var arg_idx in arguments) {\n          hit = false;\n\n          if (undefined === arguments[arg_idx].access) {\n            if (true !== hit) {\n              /* set default config */\n              this.config(arguments[arg_idx].config);\n            }\n\n            break;\n          }\n          /* check access types */\n\n\n          var orit = arguments[arg_idx].access.orientation;\n\n          if (undefined !== orit) {\n            if (\'portrait\' === orit && true !== mofron.window.isPortrait() || \'landscape\' === orit && true !== mofron.window.isLandscape()) {\n              continue;\n            }\n\n            delete arguments[arg_idx].access.orientation;\n          }\n\n          hit = comutl.chkacc(arguments[arg_idx].access);\n\n          if (true === hit) {\n            this.config(arguments[arg_idx].config);\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * \n     */\n\n  }, {\n    key: "theme",\n    value: function theme(prm) {\n      try {\n        return this.confmng("theme", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "template",\n    value: function template(tmpl, prm) {\n      try {\n        if (\'function\' !== typeof tmpl) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.child(tmpl(prm));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      try {\n        /* destroy in component layer */\n        if (null === this.parent()) {\n          return;\n        }\n\n        this.parent().getTree().delChild(this);\n        /* destroy in dom layer */\n\n        var rdom = this.rootDom();\n\n        for (var ridx in rdom) {\n          rdom[ridx].destroy();\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "size",\n    value: function size(x, y, opt) {\n      try {\n        if (undefined === x) {\n          /* getter */\n          return [this.width(), this.height()];\n        }\n        /* setter */\n\n\n        this.width(x, opt);\n        this.height(y, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "width",\n    value: function width(prm, opt) {\n      try {\n        return cmputl.size(this, "width", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        return cmputl.size(this, "height", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /*** color method ***/\n\n  }, {\n    key: "color",\n    value: function color(c1, c2, c3) {\n      try {\n        if (undefined === c1) {\n          /* getter */\n          return [this.mainColor(), this.baseColor(), this.accentColor()];\n        }\n\n        var clr_tgt = ["mainColor", "baseColor", "accentColor"];\n\n        for (var cidx in clr_tgt) {\n          if (undefined === arguments[cidx]) {\n            continue;\n          } else if (true === comutl.isinc(arguments[cidx], "ConfArg")) {\n            arguments[cidx].exec(this, clr_tgt[cidx]);\n          } else {\n            this[clr_tgt[cidx]](arguments[cidx]);\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      /* interface */\n      return null;\n    }\n  }, {\n    key: "baseColor",\n    value: function baseColor(clr, opt) {\n      try {\n        /* interface */\n        return cmputl.color(this, "background", clr, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "accentColor",\n    value: function accentColor(prm, opt) {\n      /* interface */\n      return null;\n    }\n  }, {\n    key: "visible",\n    value: function visible(flg, cbf, cbp) {\n      try {\n        return cmputl.visible(this, flg, cbf, cbp);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "config",\n    value: function config(p1, p2, p3, p4, p5) {\n      try {\n        this.rootDom();\n\n        if (0 === arguments.length) {\n          return _get(_getPrototypeOf(_class.prototype), "config", this).call(this);\n        }\n\n        _get(_getPrototypeOf(_class.prototype), "config", this).call(this, p1, p2, p3, p4, p5);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Component.js?')},"./node_modules/mofron/src/tag/Effect.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/tag/Effect.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Effect.js\n */\nvar ModConf = __webpack_require__(/*! ../core/ModConf.js */ "./node_modules/mofron/src/core/ModConf.js");\n\nvar cmputl = mofron.util.component;\nvar comutl = mofron.util.common;\nvar effutl = mofron.util.effect;\n\nmodule.exports = /*#__PURE__*/function (_ModConf) {\n  _inherits(_class, _ModConf);\n\n  var _super = _createSuper(_class);\n\n  function _class(po) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Effect\');\n\n      _this.confmng().add("callback", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("otCallback", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("beforeEvent", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("order", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("eid", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("speed", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("delay", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("timing", {\n        type: "string",\n        init: "ease",\n        select: ["ease", "linear", "ease-in", "ease-out", "ease-in-out"]\n      });\n\n      _this.confmng().add("cubic", {\n        type: "array"\n      });\n\n      _this.confmng().add("transition", {\n        type: "string",\n        list: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * execute effect\n   * \n   * @param p2 (function) simple call back\n   */\n\n\n  _createClass(_class, [{\n    key: "execute",\n    value: function execute() {\n      var _this2 = this;\n\n      try {\n        if (true === this.isSkipped(this.eid(), this.order())) {\n          return;\n        }\n\n        var trans = false;\n\n        if (0 < this.speed() && null === this.component().style("transition")) {\n          /* direct called execute() function  */\n          effutl.transition([this]);\n          trans = true;\n          this.otCallback(function (ts1, ts2, ts3) {\n            try {\n              /* release transition */\n              cmputl.rstyle(_this2.component(), {\n                \'transition\': null\n              }, {\n                bpref: true\n              });\n\n              _this2.component().styleDom().style({\n                \'transition\': null\n              }, {\n                bpref: true\n              });\n            } catch (e) {\n              console.error(e.stack);\n              throw e;\n            }\n          }, this);\n        }\n        /* execute effect */\n\n\n        var exec = function exec(exe_eff) {\n          try {\n            exe_eff.contents(exe_eff.component());\n            exe_eff.isInited(true);\n            setTimeout(exe_eff.exeCallback, exe_eff.speed() + exe_eff.delay(), exe_eff);\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        exec(this);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "fexec",\n    value: function fexec() {\n      try {\n        var sus = this.suspend();\n        this.suspend(false);\n        this.execute();\n        this.suspend(sus);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "contents",\n    value: function contents(eid, cmp) {}\n  }, {\n    key: "transition",\n    value: function transition(prm) {\n      try {\n        return this.confmng("transition", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "beforeEvent",\n    value: function beforeEvent(fnc, prm) {\n      try {\n        return this.confmng("beforeEvent", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "otCallback",\n    value: function otCallback(fnc, prm) {\n      try {\n        var ret = this.confmng("otCallback", fnc, prm);\n\n        if (undefined !== ret) {\n          this.confmng()["delete"]("otCallback");\n          return ret;\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * @param p1 (array) [function, param, one time flag]\n     */\n\n  }, {\n    key: "callback",\n    value: function callback(fnc, prm) {\n      try {\n        return this.confmng("callback", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "exeCallback",\n    value: function exeCallback(eff) {\n      try {\n        /* execute callback */\n        var cb = eff.callback();\n\n        for (var cidx1 in cb) {\n          cb[cidx1][0](eff, eff.component(), cb[cidx1][1]);\n        }\n\n        var ocb = eff.otCallback();\n\n        for (var cidx2 in ocb) {\n          ocb[cidx2][0](eff, eff.component(), ocb[cidx2][1]);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isSkipped",\n    value: function isSkipped(eid, ord) {\n      try {\n        if (true === this.suspend() || eid !== this.eid() || ord !== this.order()) {\n          return true;\n        }\n\n        return false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * execute order number setter/getter\n     *\n     * @param p1 (number) execute order number\n     * @param p1 (undefined) call as getter\n     * @return (number) execute order number\n     */\n\n  }, {\n    key: "order",\n    value: function order(prm) {\n      try {\n        return this.confmng("order", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "eid",\n    value: function eid(prm) {\n      try {\n        return this.confmng("eid", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /*** default execute config ***/\n\n    /**\n     * effect speed setter/getter\n     *\n     * @param p1 (number) effect speed\n     * @param p1 (undefined) call as getter\n     * @return (number) effect speed\n     */\n\n  }, {\n    key: "speed",\n    value: function speed(prm) {\n      try {\n        return this.confmng("speed", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "delay",\n    value: function delay(prm) {\n      try {\n        return this.confmng("delay", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "timing",\n    value: function timing(prm) {\n      try {\n        return this.confmng("timing", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "cubicBezier",\n    value: function cubicBezier(p1, p2, p3, p4) {\n      try {\n        if (undefined === p1) {\n          return this.confmng("cubic");\n        }\n\n        if ("number" !== typeof p1 || "number" !== typeof p2 || "number" !== typeof p3 || "number" !== typeof p4) {\n          throw new Error("invalid parameter");\n        }\n\n        this.confmng("cubic", [p1, p2, p3, p4]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(ModConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Effect.js?')},"./node_modules/mofron/src/tag/Event.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/src/tag/Event.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file event.js\n * @author simpart\n */\nvar ModConf = __webpack_require__(/*! ../core/ModConf.js */ "./node_modules/mofron/src/core/ModConf.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_ModConf) {\n  _inherits(_class, _ModConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   */\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Event\');\n\n      _this.shortForm(\'listener\');\n\n      _this.confmng().add("listener", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("eid", {\n        type: "number"\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * set function for event listener\n   *\n   * @param fnc : (function) function for event listener\n   * @param prm : (mixed) function parameter (option)\n   */\n\n\n  _createClass(_class, [{\n    key: "listener",\n    value: function listener(fnc, prm) {\n      try {\n        return this.confmng("listener", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "execListener",\n    value: function execListener(eprm) {\n      try {\n        if (true === this.suspend()) {\n          return;\n        }\n\n        var lis = this.listener();\n        var prm = null;\n\n        for (var lidx in lis) {\n          lis[lidx][0](this.component(), eprm, lis[lidx][1]);\n        }\n        /* execute effect */\n\n\n        if (null !== this.eid()) {\n          this.component().execEffect(this.eid());\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "execute",\n    value: function execute() {\n      try {\n        this.initevt();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "initevt",\n    value: function initevt() {\n      try {\n        if (false === this.isInited()) {\n          this.contents(this.component().eventDom());\n          this.isInited(true);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "eid",\n    value: function eid(prm) {\n      try {\n        return this.confmng("eid", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(ModConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Event.js?')},"./node_modules/mofron/src/tag/Layout.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/tag/Layout.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file layout/Base.js\n * @brief Base class of layout\n */\nvar ModConf = __webpack_require__(/*! ../core/ModConf.js */ "./node_modules/mofron/src/core/ModConf.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_ModConf) {\n  _inherits(_class, _ModConf);\n\n  var _super = _createSuper(_class);\n\n  function _class(po) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Layout\');\n\n      _this.confmng().add("skip", {\n        type: "Component",\n        list: true\n      });\n\n      _this.confmng().add("execlog", {\n        type: "Component",\n        list: true\n      }); //this.m_execnt = 0;\n\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "execute",\n    value: function execute() {\n      try {\n        var cmp_chd = this.component().child();\n\n        for (var _cidx in cmp_chd) {\n          /* check skip */\n          if (true === this.isSkipped(cmp_chd[_cidx])) {\n            continue;\n          }\n\n          if (false === this.isExeced(cmp_chd[_cidx])) {\n            /* execute layout contents */\n            this.contents(parseInt(_cidx), cmp_chd[_cidx]);\n            this.confmng("execlog", cmp_chd[_cidx]);\n          }\n        }\n\n        this.isInited(true);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isExeced",\n    value: function isExeced(cmp) {\n      try {\n        var elog = this.confmng("execlog");\n\n        for (var eidx in elog) {\n          if (elog[eidx].id() === cmp.id()) {\n            return true;\n          }\n        }\n\n        return false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "contents",\n    value: function contents(idx, tgt) {\n      console.warn(\'not implement\');\n    }\n  }, {\n    key: "skip",\n    value: function skip(prm) {\n      try {\n        return this.confmng("skip", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isSkipped",\n    value: function isSkipped(cmp) {\n      try {\n        var skp = this.skip();\n\n        for (var sidx in skp) {\n          if (skp[sidx].id() === cmp[cidx].id()) {\n            return true;\n          }\n        }\n\n        return false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(ModConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Layout.js?')},"./node_modules/mofron/src/type/Color.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/type/Color.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  Color.js\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../core/Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Color\');\n\n      _this.m_rgba = [null, null, null, null];\n      /* red, green, blue, alpha */\n\n      if (true === Array.isArray(prm)) {\n        _this.rgba(prm[0], prm[1], prm[2], prm[3]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "rgb",\n    value: function rgb(r, g, b) {\n      try {\n        var ret = this.rgba(r, g, b);\n        return undefined !== ret ? [ret[0], ret[1], ret[2]] : undefined;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get rgba value\n     * \n     * @return (object) rgba array object\n     *   [0] -> (number) red value\n     *   [1] -> (number) green value\n     *   [2] -> (number) blue value\n     *   [3] -> (number) alpha value\n     */\n\n  }, {\n    key: "rgba",\n    value: function rgba(red, green, blue, alpha) {\n      try {\n        if (undefined === red) {\n          /* getter */\n          return this.m_rgba;\n        }\n        /* setter */\n\n\n        var _red = red === undefined ? null : red;\n\n        var _green = green === undefined ? null : green;\n\n        var _blue = blue === undefined ? null : blue;\n\n        var _alpha = alpha === undefined ? 1 : alpha;\n\n        if (null === _red && null === _green && null === _blue) {} else if (null !== _red && null !== _green && null !== _blue) {\n          if (\'number\' !== typeof _red || \'number\' !== typeof _green || \'number\' !== typeof _blue) {\n            throw new Error(\'invalid parameter\');\n          }\n        } else {\n          throw new Error(\'invalid parameter\');\n        }\n\n        if (\'number\' !== typeof _alpha) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.m_rgba[0] = _red;\n        this.m_rgba[1] = _green;\n        this.m_rgba[2] = _blue;\n        this.m_rgba[3] = _alpha;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get coloe style value\n     *\n     * @return (string) rgba(x,x,x,x)\n     * @return (string) none\n     * @note return \'none\' if rgb is null.\n     */\n\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        var rgba = this.rgba();\n        var red = rgba[0];\n        var green = rgba[1];\n        var blue = rgba[2];\n        var alpha = rgba[3];\n\n        if (null === red && null === green && null === blue) {\n          return \'none\';\n        }\n\n        return \'rgba(\' + red + \',\' + green + \',\' + blue + \',\' + alpha + \')\';\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/Color.js?')},"./node_modules/mofron/src/type/ConfArg.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/type/ConfArg.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file ConfArg.js\n * @brief config argument class\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../core/Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname("ConfArg");\n\n      _this.param(arguments);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "exec",\n    value: function exec(tgt, fnc) {\n      try {\n        var arg = this.param();\n\n        if (true === Array.isArray(fnc)) {\n          if (1 === fnc.length) {\n            this.exec(tgt, fnc[0]);\n          } else {\n            if (fnc.length < arg.length) {\n              throw new Error("mismatched config count");\n            }\n\n            for (var aidx in arg) {\n              if ("function" !== typeof tgt[fnc[aidx]]) {\n                console.warn("invalid config: " + fnc[aidx]);\n                continue;\n              }\n\n              if (true === comutl.isinc(arg[aidx], "ConfArg")) {\n                arg[aidx].exec(tgt, fnc[aidx]);\n              } else {\n                tgt[fnc[aidx]](arg[aidx]);\n              }\n            }\n          }\n\n          return;\n        } else if ("string" === typeof fnc) {\n          if ("function" !== typeof tgt[fnc]) {\n            console.warn("invalid config: " + fnc);\n            return;\n          }\n\n          if (0 === arg.length) {\n            tgt[fnc]();\n          } else if (1 === arg.length) {\n            tgt[fnc](arg[0]);\n          } else if (2 === arg.length) {\n            tgt[fnc](arg[0], arg[1]);\n          } else if (3 === arg.length) {\n            tgt[fnc](arg[0], arg[1], arg[2]);\n          } else if (4 === arg.length) {\n            tgt[fnc](arg[0], arg[1], arg[2], arg[3]);\n          } else {\n            tgt[fnc](arg[0], arg[1], arg[2], arg[3], arg[4]);\n          }\n        } else {\n          throw new Error("invalid parameter");\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "param",\n    value: function param(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          if (undefined === this.m_param) {\n            throw new Error("could not find param");\n          }\n\n          return this.m_param;\n        }\n        /* setter */\n\n\n        if ("object" !== _typeof(prm)) {\n          throw new Error("invalid parameter");\n        }\n\n        var arg = [];\n        var hit = false;\n\n        for (var pidx = prm.length; pidx >= 0; pidx--) {\n          if (true === hit) {\n            arg.unshift(prm[pidx]);\n          } else if (undefined !== prm[pidx]) {\n            arg.unshift(prm[pidx]);\n            hit = true;\n          }\n        }\n\n        this.m_param = arg;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "addParam",\n    value: function addParam(prm) {\n      try {\n        this.m_param.push(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/ConfArg.js?')},"./node_modules/mofron/src/type/PullConf.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/type/PullConf.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file pullConf.js\n * @brief pull type config argument class\n * @author simpart\n */\nvar ConfArg = __webpack_require__(/*! ./ConfArg.js */ "./node_modules/mofron/src/type/ConfArg.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_ConfArg) {\n  _inherits(_class, _ConfArg);\n\n  var _super = _createSuper(_class);\n\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      if (!(\'object\' === _typeof(prm) && false === Array.isArray(prm) && false === comutl.isinc(prm, "Base"))) {\n        throw new Error("invalid parameter");\n      }\n\n      _this = _super.call(this, prm);\n\n      _this.modname("PullConf");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "exec",\n    value: function exec(tgt, fnc) {\n      try {\n        tgt[fnc]().config(this.param()[0]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(ConfArg);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/PullConf.js?')},"./node_modules/mofron/src/type/size/Pixel.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Pixel.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  Pixel.js\n * @brief pixel size data type\n * @author simpart\n */\nvar Size = __webpack_require__(/*! ./Size.js */ "./node_modules/mofron/src/type/size/Size.js");\n\nmodule.exports = /*#__PURE__*/function (_Size) {\n  _inherits(_class, _Size);\n\n  var _super = _createSuper(_class);\n\n  /**\n   *\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, prm, \'px\');\n\n      _this.modname(\'Pixel\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "toPixel",\n    value: function toPixel() {\n      try {\n        return this.value();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Size);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Pixel.js?')},"./node_modules/mofron/src/type/size/Rem.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Rem.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  Rem.js\n * @brief rem size data type\n * @author simpart\n */\nvar Size = __webpack_require__(/*! ./Size.js */ "./node_modules/mofron/src/type/size/Size.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Size) {\n  _inherits(_class, _Size);\n\n  var _super = _createSuper(_class);\n\n  /**\n   *\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, prm, \'rem\');\n\n      _this.modname(\'Rem\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "toPixel",\n    value: function toPixel() {\n      try {\n        /* get html font-size */\n        var h_fsiz = document.documentElement.style["fontSize"];\n\n        if ("" === h_fsiz) {\n          h_fsiz = 625; // default size\n        } else {\n          h_fsiz = parseFloat(h_fsiz);\n        }\n        /* get body font-size */\n\n\n        var b_fsiz = document.body.style["fontSize"];\n\n        if ("" === b_fsiz) {\n          b_fsiz = "0.16"; // default size\n        } else {\n          b_fsiz = parseFloat(b_fsiz);\n        }\n\n        return this.value() * (b_fsiz * h_fsiz);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "calcu",\n    value: function calcu(prm, flg) {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "calcu", this).call(this, prm, flg);\n\n        if (\'px\' === this.type()) {\n          this.value(this.px2Rem());\n          this.type(\'rem\');\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Size);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Rem.js?')},"./node_modules/mofron/src/type/size/Size.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Size.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  Size.js\n * @brief size data type\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../../core/Base.js */ "./node_modules/mofron/src/core/Base.js");\n/**\n * @class Size\n * @brief Size Defined Class\n */\n\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  /**\n   *\n   */\n  function _class(siz, tp) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.modname(\'Size\');\n\n      _this.confmng().add("type", {\n        type: "string",\n        init: ""\n      });\n\n      _this.confmng().add("value", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("option", {\n        type: "object",\n        init: {}\n      });\n\n      if (\'number\' === typeof siz && \'string\' === typeof tp) {\n        _this.value(siz);\n\n        _this.type(tp);\n      } else {\n        throw new Error("invalid parameter");\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.confmng("value", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "option",\n    value: function option(prm) {\n      try {\n        return this.confmng("option", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toStyle",\n    value: function toStyle() {\n      try {\n        return [this.toString(), this.option()];\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        return null === this.type() ? null : this.value() + this.type();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toPixel",\n    value: function toPixel() {\n      try {\n        throw new Error("not supported");\n      } catch (e) {\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Size.js?')},"./node_modules/mofron/src/util/common.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/util/common.js ***!
  \************************************************/
/*! no static exports found */function(module,exports){eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * @file common.js\n * @brief common util functions\n */\nmofron.util.common = {\n  isinc: function isinc(obj, nm) {\n    try {\n      /* parameter check */\n      if (null === obj || 'object' !== _typeof(obj) || true === Array.isArray(obj) || \"function\" !== typeof obj.modname || \"function\" !== typeof obj.confmng) {\n        return false;\n      }\n\n      var chk_nm = \"string\" === typeof nm ? [nm] : nm;\n      var chk_idx = 0;\n      var name_lst = obj.confmng(\"modname\");\n\n      for (var idx in name_lst) {\n        if (chk_nm[chk_idx] === name_lst[idx]) {\n          chk_idx++;\n\n          if (chk_nm.length === chk_idx) {\n            return true;\n          }\n\n          continue;\n        }\n\n        if (0 < chk_idx) {\n          break;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  iscmp: function iscmp(obj) {\n    try {\n      return comutl.isinc(obj, \"Component\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  isobj: function isobj(obj, nm) {\n    try {\n      return obj.modname() === nm ? true : false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getcmp: function getcmp(prm) {\n    try {\n      return new mofron[\"class\"].Component(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getcolor: function getcolor(prm) {\n    try {\n      if (null === prm || undefined === prm) {\n        return null;\n      } else if ('string' === typeof prm) {\n        if ('none' === prm) {\n          return new mofron[\"class\"].Color();\n        } else if (0 === prm.indexOf('rgb')) {\n          var rgb_clr = null;\n\n          if (0 === prm.indexOf('rgba(')) {\n            rgb_clr = prm.substring(5);\n          } else if (0 === prm.indexOf('rgb(')) {\n            rgb_clr = prm.substring(4);\n          } else {\n            throw new Error('invalid parameter');\n          }\n\n          rgb_clr = rgb_clr.substring(0, rgb_clr.length - 1);\n          rgb_clr = rgb_clr.split(',');\n\n          if (3 === rgb_clr.length) {\n            return new mofron[\"class\"].Color([parseInt(rgb_clr[0]), parseInt(rgb_clr[1]), parseInt(rgb_clr[2])]);\n          } else if (4 === rgb_clr.length) {\n            return new mofron[\"class\"].Color([parseInt(rgb_clr[0]), parseInt(rgb_clr[1]), parseInt(rgb_clr[2]), parseInt(rgb_clr[3])]);\n          } else {\n            throw new Error('invalid parameter');\n          }\n        } else if (0 === prm.indexOf('#')) {\n          /* hex */\n          var hex_clr = prm.substring(1);\n\n          if (6 !== hex_clr.length) {\n            throw new Error('invalid parameter');\n          }\n\n          return new mofron[\"class\"].Color([parseInt(hex_clr.substring(0, 2), 16), parseInt(hex_clr.substring(2, 4), 16), parseInt(hex_clr.substring(4, 6), 16)]);\n        } else {\n          /* name */\n          if ('string' !== typeof prm) {\n            throw new Error('invalid parameter');\n          }\n\n          switch (prm) {\n            case 'black':\n              return new mofron[\"class\"].Color([0, 0, 0]);\n\n            case 'gray':\n              return new mofron[\"class\"].Color([128, 128, 128]);\n\n            case 'silver':\n              return new mofron[\"class\"].Color([192, 192, 192]);\n\n            case 'white':\n              return new mofron[\"class\"].Color([255, 255, 255]);\n\n            case 'blue':\n              return new mofron[\"class\"].Color([0, 0, 255]);\n\n            case 'navy':\n              return new mofron[\"class\"].Color([0, 0, 128]);\n\n            case 'teal':\n              return new mofron[\"class\"].Color([0, 128, 128]);\n\n            case 'green':\n              return new mofron[\"class\"].Color([0, 128, 0]);\n\n            case 'lime':\n              return new mofron[\"class\"].Color([0, 255, 0]);\n\n            case 'aqua':\n              return new mofron[\"class\"].Color([0, 255, 255]);\n\n            case 'yellow':\n              return new mofron[\"class\"].Color([255, 255, 0]);\n\n            case 'red':\n              return new mofron[\"class\"].Color([255, 0, 0]);\n\n            case 'fuchsia':\n              return new mofron[\"class\"].Color([255, 0, 255]);\n\n            case 'olive':\n              return new mofron[\"class\"].Color([128, 128, 0]);\n\n            case 'purple':\n              return new mofron[\"class\"].Color([128, 0, 128]);\n\n            case 'maroon':\n              return new mofron[\"class\"].Color([128, 0, 0]);\n\n            default:\n              throw new Error('not supported color');\n          }\n        }\n      } else if (true === Array.isArray(prm)) {\n        return new mofron[\"class\"].Color(prm);\n      } else if (true === comutl.isinc(prm, 'Color')) {\n        return prm;\n      } else {\n        throw new Error('invalid parameter');\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getsize: function getsize(prm) {\n    try {\n      var siz = null;\n      /* parameter check */\n\n      if ('string' !== typeof prm) {\n        if (null === prm || undefined === prm) {\n          return null;\n        } else if (true === comutl.isinc(prm, \"Size\")) {\n          return prm;\n        } else {\n          throw new Error('invalid parameter');\n        }\n      }\n      /* get size type */\n\n\n      var stype = ['px', '%', 'rem', 'em', 'vw', 'vh'];\n      var ptype = null;\n\n      for (var sidx in stype) {\n        if (2 !== prm.split(stype[sidx]).length) {\n          continue;\n        }\n\n        ptype = stype[sidx];\n        break;\n      }\n\n      if (null === ptype) {\n        throw new Error('not supported size type');\n      }\n      /* get value */\n\n\n      var sval = null;\n      sp_prm = prm.split(ptype);\n\n      if (2 === sp_prm[0].split('.').length) {\n        sval = parseFloat(sp_prm[0]);\n      } else {\n        sval = parseInt(sp_prm[0]);\n      }\n\n      if ('px' === ptype) {\n        return new mofron[\"class\"].Pixel(sval);\n      } else if ('rem' === ptype) {\n        return new mofron[\"class\"].Rem(sval);\n      } else {\n        return new mofron[\"class\"].Size(sval, ptype);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  sizetype: function sizetype(prm) {\n    try {\n      var size = comutl.getsize(prm);\n      return null === size ? null : size.type();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  sizesum: function sizesum(p1, p2) {\n    try {\n      var prm1 = 'string' === typeof p1 ? comutl.getsize(p1) : p1;\n      var prm2 = 'string' === typeof p2 ? comutl.getsize(p2) : p2;\n\n      if (null == prm1 && true === comutl.isinc(prm2, ['Base', 'Size'])) {\n        return prm2.toString();\n      } else if (null == prm2 && true === comutl.isinc(prm1, ['Base', 'Size'])) {\n        return prm1.toString();\n      } else if (null === prm1 && null === prm2) {\n        return null;\n      }\n\n      if (true !== comutl.isinc(prm1, ['Base', 'Size']) || true !== comutl.isinc(prm2, ['Base', 'Size'])) {\n        throw new Error('invalid parameter');\n      }\n\n      if (prm1.type() !== prm2.type()) {\n        if (undefined === prm1.toPixel() || undefined === prm2.toPixel()) {\n          throw new Error('not supported type');\n        }\n\n        return new mofron[\"class\"].Pixel(prm1.toPixel() + prm2.toPixel()).toString();\n      } else {\n        var val_1 = comutl.roundup(prm1.value());\n        var val_2 = comutl.roundup(prm2.value());\n        return comutl.roundup(val_1 + val_2) + prm1.type();\n      }\n    } catch (e) {\n      throw e;\n    }\n  },\n  sizediff: function sizediff(p1, p2) {\n    try {\n      var prm2 = 'string' === typeof p2 ? comutl.getsize(p2) : p2;\n\n      if (true !== comutl.isinc(prm2, \"Size\")) {\n        throw new Error('not supported type');\n      }\n\n      var prm2_buf = comutl.getsize(prm2.toString());\n      prm2_buf.value(prm2_buf.value() * -1);\n      return comutl.sizesum(p1, prm2_buf);\n    } catch (e) {\n      throw e;\n    }\n  },\n  roundup: function roundup(prm) {\n    try {\n      var flo = comutl.flo2int(prm);\n\n      if (1000 >= flo[1]) {\n        return prm;\n      }\n\n      return Math.floor(flo[0] / flo[1] * 1000) / 1000;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  flo2int: function flo2int(prm) {\n    try {\n      if ('number' !== typeof prm) {\n        throw new Error('invalid parameter');\n      }\n\n      var chk = null;\n      var pos = 0;\n      var wei = 1;\n      chk = prm + '';\n      pos = chk.indexOf('.');\n\n      if (-1 === pos) {\n        return [prm, 1];\n      }\n\n      for (pos = chk.length - 1 - pos; 0 < pos; pos--) {\n        wei = wei * 10;\n      }\n\n      return [prm * wei, wei];\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  chkacc: function chkacc(opt) {\n    try {\n      for (var oidx in opt) {\n        if (\"device\" !== oidx && \"os\" !== oidx && \"browser\" !== oidx && \"orientation\" !== oidx) {\n          console.warn(\"unknown index:\" + oidx);\n          return false;\n        }\n\n        if (\"device\" === oidx) {\n          if (opt[oidx] !== comutl.accdev()) {\n            return false;\n          }\n        } else if (\"os\" === oidx) {\n          if (opt[oidx] !== comutl.accos()) {\n            return false;\n          }\n        } else if (\"browser\" === oidx) {\n          if (opt[oidx] !== comutl.accbrs()) {\n            return false;\n          }\n        } else if (\"orientation\" === oidx) {\n          var ochk = \"portrait\" === opt.orientation ? true : false;\n\n          if (ochk !== mofron.window.isPortrait()) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accdev: function accdev() {\n    try {\n      var ua = window.navigator.userAgent;\n\n      if (ua.indexOf('iPhone') > 0 || ua.indexOf('iPod') > 0 || ua.indexOf('Android') > 0 && ua.indexOf('Mobile') > 0) {\n        return 'mobile';\n      } else if (ua.indexOf('iPad') > 0 || ua.indexOf('Android') > 0) {\n        return 'tablet';\n      } else {\n        return 'other';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accos: function accos() {\n    try {\n      var ua = window.navigator.userAgent;\n\n      if (ua.indexOf('iPhone') > 0 || ua.indexOf('iPod') > 0 || ua.indexOf('iPad') > 0) {\n        return 'ios';\n      } else if (ua.indexOf('Android') > 0) {\n        return 'android';\n      } else if (ua.indexOf('Windows') > 0) {\n        return 'windows';\n      } else if (ua.indexOf('Mac OS') > 0) {\n        return 'mac';\n      } else if (ua.indexOf('Linux') > 0) {\n        return 'linux';\n      } else {\n        return 'other';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accbrs: function accbrs() {\n    try {\n      var ua = window.navigator.userAgent.toLowerCase();\n\n      if (ua.indexOf('msie') !== -1 || ua.indexOf('trident') !== -1) {\n        return 'ie';\n      } else if (ua.indexOf('edge') != -1) {\n        return 'edge';\n      } else if (ua.indexOf('chrome') != -1) {\n        return 'chrome';\n      } else if (ua.indexOf('safari') != -1) {\n        return 'safari';\n      } else if (ua.indexOf('firefox') != -1) {\n        return 'firefox';\n      } else if (ua.indexOf('opera') != -1) {\n        return 'opera';\n      } else {\n        return 'other';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  addhead: function addhead(tag, atr, txt) {\n    try {\n      var conts = \"<\" + tag + \" \";\n      /* set attributes */\n\n      for (var aidx in atr) {\n        conts += aidx + '=' + atr[aidx] + ' ';\n      }\n\n      conts = conts.substring(0, conts.length - 1) + \">\";\n\n      if ('link' !== tag && 'meta' !== tag && 'base' !== tag) {\n        /* set contents */\n        conts += txt + \"</\" + tag + \">\";\n      }\n\n      if (undefined !== mofron.ssr) {\n        mofron.ssr.head(conts);\n      } else {\n        document.head.insertAdjacentHTML('beforeend', conts);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  addstyle: function addstyle(id, prm, append) {\n    try {\n      var style = document.getElementById(id);\n\n      if (null === style) {\n        comutl.addhead(\"style\", {\n          id: id\n        }, prm);\n      } else if (false !== append) {\n        style.innerText += prm;\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  obj2style: function obj2style(sel, cnt) {\n    try {\n      var ret = sel + \" {\";\n\n      for (var cidx in cnt) {\n        ret += cidx + \":\" + cnt[cidx] + \";\";\n      }\n\n      return ret + \"}\";\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nvar comutl = mofron.util.common;\nmodule.exports = mofron.util.common;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/common.js?")},"./node_modules/mofron/src/util/component.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/util/component.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports){eval('var _arguments = arguments;\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * @file component.js\n * @brief util functions for component\n * @license MIT\n */\nvar comutl = mofron.util.common;\nmofron.util.component = {\n  /*** define ***/\n  IDX_LAYOUT: 0,\n  IDX_EFFECT: 1,\n  IDX_EVENT: 2,\n  IDX_EFFECT_ZSP: 3,\n  chdloop: function chdloop(cmp, key, p1, p2, p3) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var _chd = cmp.getTree().getChild();\n\n      var argc = _arguments.length;\n\n      for (var cidx in _chd) {\n        if (2 === argc) {\n          _chd[cidx][key](p1);\n        } else if (3 === argc) {\n          _chd[cidx][key](p1, p2);\n        } else if (4 === argc) {\n          _chd[cidx][key](p1, p2, p3);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  ischild: function ischild(pnt, cmp) {\n    try {\n      var ret = false;\n      var pchd = pnt.getTree().child();\n\n      for (var cidx in pchd) {\n        if (true === comutl.ischild(chd[cidx], cmp)) {\n          return true;\n        } else if (chd[cidx].id() === cmp.id()) {\n          return true;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  isinncmp: function isinncmp(cmp) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var chd_cmp = cmp.childDom().component();\n\n      if (null === chd_cmp || null === chd_cmp.getTree().parent()) {\n        return false;\n      }\n\n      var pnt_buf = chd_cmp.getTree().parent();\n\n      while (null !== pnt_buf) {\n        if (cmp.id() === pnt_buf.id()) {\n          /* target is inner component */\n          return true;\n        }\n\n        pnt_buf = pnt_buf.getTree().parent();\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  modconf: function modconf(cmp, idx, po) {\n    try {\n      if (true === comutl.isinc(po, "ModConf") && true === po.innerTgt() && true === cmputl.isinncmp(cmp)) {\n        return cmputl.modconf(cmp.childDom().component(), idx, po);\n      }\n\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var cnf_key = ["layout", "effect", "event"];\n\n      if (undefined === cnf_key[idx]) {\n        throw new Error(\'invalid parameter\');\n      }\n\n      if (true === Array.isArray(po)) {\n        for (var pidx in po) {\n          cmputl.modconf(cmp, idx, po[pidx]);\n        }\n\n        return;\n      }\n\n      if (false === comutl.isinc(po, "ModConf")) {\n        /* getter */\n        var get_cmp = true === cmputl.isinncmp(cmp) ? cmp.childDom().component() : cmp;\n        var mc_ret = get_cmp.confmng().get(cnf_key[idx]);\n\n        if ("object" !== _typeof(po) || false !== Array.isArray(po)) {\n          return mc_ret;\n        }\n\n        var ret = [];\n        var hit = null;\n\n        for (var midx in mc_ret) {\n          hit = true;\n\n          for (var _pidx in po) {\n            if (mc_ret[midx][_pidx]() !== po[_pidx]) {\n              hit = false;\n              break;\n            }\n          }\n\n          if (true === hit) {\n            ret.push(mc_ret[midx]);\n          }\n        }\n\n        return 0 === ret.length ? null : ret;\n      }\n      /* setter */\n\n\n      po.component(cmp);\n      cmp.confmng(cnf_key[idx], po);\n\n      if (true === cmp.isExists() && cmputl.IDX_EFFECT !== idx) {\n        po.execute();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  initmconf: function initmconf(cmp, idx) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var _chd2 = cmp.getTree().getChild();\n\n      for (var cidx in _chd2) {\n        cmputl.initmconf(_chd2[cidx], idx);\n      }\n      /* init module config */\n\n\n      if (cmputl.IDX_EFFECT === idx || cmputl.IDX_EFFECT_ZSP === idx) {\n        /* init effect */\n        var efflst = cmputl.modconf(cmp, cmputl.IDX_EFFECT);\n        var eid = "none" !== cmp.style("display") ? 0 : 1;\n        var oid = 0;\n        var exelst = [];\n\n        while (true) {\n          efflst = mofron.util.effect.getlist(efflst, eid, oid);\n\n          if (0 === efflst.length) {\n            break;\n          }\n\n          oid++;\n\n          for (var eidx in efflst) {\n            if (idx === cmputl.IDX_EFFECT && 0 !== efflst[eidx].speed() || idx === cmputl.IDX_EFFECT_ZSP && 0 === efflst[eidx].speed()) {\n              exelst.push(efflst[eidx]);\n            }\n          }\n        }\n\n        mofron.util.effect.exec(exelst, eid);\n      } else {\n        var cnf = cmputl.modconf(cmp, idx);\n\n        for (var cfidx in cnf) {\n          cnf[cfidx].execute();\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  theme: function theme(cmp, thm, r_rep) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var cmp_thm = cmp.theme();\n      var exe_thm = {};\n\n      for (var thm_idx in thm) {\n        exe_thm[thm_idx] = thm[thm_idx];\n      }\n\n      for (var cmp_idx in cmp_thm) {\n        exe_thm[cmp_idx] = cmp_thm[cmp_idx];\n      }\n\n      var _theme = function _theme(ch, eth) {\n        try {\n          var buf_thm = {};\n\n          for (var exe_idx in eth) {\n            buf_thm[exe_idx] = eth[exe_idx];\n          }\n\n          cmputl.theme(ch, buf_thm, false);\n          /* execute theme */\n\n          for (var tidx in eth) {\n            if (true === comutl.isinc(ch, tidx)) {\n              if (undefined !== eth[tidx].replace) {\n                /* replace component */\n                eth[tidx].replace.config(ch.config());\n                cmp.getTree().replace(ch, eth[tidx].replace);\n              } else {\n                ch.config(eth[tidx].config);\n              }\n            }\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n\n      var _chd3 = cmp.getTree().getChild();\n\n      for (var cidx in _chd3) {\n        _theme(_chd3[cidx], exe_thm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  size: function size(cmp, key, val, opt) {\n    try {\n      /* setter */\n      if (false === comutl.iscmp(cmp) || "string" !== typeof key) {\n        throw new Error("invalid parameter");\n      }\n\n      if (undefined === val) {\n        /* getter */\n        return cmp.style(key);\n      }\n      /* setter */\n\n\n      var style_val = {};\n\n      if (null === comutl.getsize(val)) {\n        style_val[key] = null;\n      } else {\n        style_val[key] = comutl.getsize(val).toString();\n      }\n\n      cmp.config({\n        style: new mofron["class"].ConfArg(style_val, opt)\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  color: function color(cmp, key, val, opt) {\n    try {\n      if (false === comutl.iscmp(cmp) || "string" !== typeof key) {\n        throw new Error("invalid parameter");\n      }\n\n      if (undefined === val) {\n        /* getter */\n        return cmp.style(key);\n      }\n      /* setter */\n\n\n      var style_val = {};\n      style_val[key] = null === val ? null : comutl.getcolor(val).toString();\n      cmp.style(style_val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  display: function display(cmp, flg) {\n    try {\n      /* check parameter */\n      if (false === comutl.iscmp(cmp) || \'boolean\' !== typeof flg) {\n        throw new Error(\'invalid parameter\');\n      }\n\n      var buf = null;\n      var rdom = cmp.rootDom();\n\n      for (var ridx in rdom) {\n        if (true === flg) {\n          /* diplayed target dom, set display value from buffer */\n          if (\'none\' === rdom[ridx].style("display") && true === rdom[ridx].isPushed()) {\n            buf = cmputl.dispbuff(rdom[ridx]);\n            rdom[ridx].style({\n              "display": undefined === buf ? null : buf\n            });\n            cmputl.dispbuff(rdom[ridx], null);\n          }\n        } else {\n          /* hidden target dom, buffering display value */\n          buf = rdom[ridx].style("display");\n\n          if (\'none\' !== buf && null !== buf) {\n            cmputl.dispbuff(rdom[ridx], buf);\n          }\n\n          rdom[ridx].style({\n            "display": "none"\n          });\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  dispbuff: function dispbuff(dom, val) {\n    try {\n      if (false === comutl.isinc(dom, "Dom")) {\n        throw new Error("invalid parameter");\n      }\n\n      var dkey = dom.id() + "_display";\n\n      if (undefined === val) {\n        /* getter */\n        return dom.data(dkey);\n      }\n      /* setter */\n\n\n      dom.data(dkey, val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  visible: function visible(cmp, vflg, ef, ep) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      if (undefined === vflg) {\n        /* getter */\n        if (false === cmp.isExists()) {\n          /* it does not rendered yet */\n          return false;\n        }\n\n        var doms = cmp.rootDom();\n\n        for (var didx in doms) {\n          if (\'none\' !== doms[didx].style(\'display\')) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /* setter */\n\n\n      if (\'boolean\' !== typeof vflg) {\n        throw new Error(\'invalid parameter\');\n      }\n\n      if (false === cmp.isExists()) {\n        /* render component */\n        cmputl.display(cmp, vflg);\n\n        if (true === vflg) {\n          cmputl.render(cmp, ef, ep);\n        }\n\n        return;\n      } else if (true === vflg) {\n        cmputl.display(cmp, vflg);\n      }\n\n      var scb = function scb() {\n        try {\n          if (false === vflg) {\n            cmputl.display(cmp, false);\n          }\n\n          if ("function" === typeof ef) {\n            ef(cmp, cmp.visible(), ep);\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n\n      if (false === cmp.execEffect(true === vflg ? 0 : 1, scb)) {\n        /* it doesn\'t execute effect */\n        scb();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  render: function render(cmp, cbf, cbp) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n      /* execute layout modules */\n\n\n      cmputl.initmconf(cmp, cmputl.IDX_LAYOUT);\n      /* execute theme */\n\n      cmputl.theme(cmp, {});\n      /* before push event */\n\n      cmp.beforeRender();\n      /* execute effect module that is 0 speed */\n\n      cmputl.initmconf(cmp, cmputl.IDX_EFFECT_ZSP);\n      /* render */\n\n      var rdom = cmp.rootDom();\n\n      for (var ridx in rdom) {\n        if (null === rdom[ridx].parent()) {\n          rdom[ridx].push({\n            target: document.body\n          });\n        } else {\n          var cmp_idx = cmp.parent().getTree().getIndex(cmp);\n          var pc_len = cmp.parent().child().length;\n\n          if (1 === pc_len || cmp_idx === pc_len - 1) {\n            /* insert to last of parent */\n            rdom[ridx].push({\n              target: rdom[ridx].parent().getRawDom()\n            });\n          } else {\n            /* insert to target index of parent */\n            rdom[ridx].push({\n              target: cmp.parent().child()[cmp_idx].rootDom()[0].getRawDom(),\n              position: \'beforebegin\'\n            });\n          }\n        }\n      }\n      /* after push event */\n\n\n      cmp.afterRender();\n\n      if ("function" === typeof cbf) {\n        cbf(cmp, cmp.visible(), cbp);\n      }\n      /* execute effect modules */\n\n\n      cmputl.initmconf(cmp, cmputl.IDX_EFFECT);\n      /* execute event modules */\n\n      cmputl.initmconf(cmp, cmputl.IDX_EVENT);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  rstyle: function rstyle(cmp, sty, opt) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var root = cmp.rootDom();\n\n      for (var ridx in root) {\n        root[ridx].style(sty, opt);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nvar cmputl = mofron.util.component;\nmodule.exports = mofron.util.component;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/component.js?')},"./node_modules/mofron/src/util/effect.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/util/effect.js ***!
  \************************************************/
/*! no static exports found */function(module,exports){eval("/**\n * @file effect.js\n */\nvar cmputl = mofron.util.component;\nmofron.util.effect = {\n  exec: function exec(eff, eid, evf, oid) {\n    try {\n      var _oid = undefined === oid ? 0 : oid;\n\n      var elst = effutl.getlist(eff, eid, _oid);\n\n      if (0 === elst.length) {\n        return false;\n      }\n      /* execute before event */\n\n\n      for (var eidx in eff) {\n        var b_evt = eff[eidx].beforeEvent();\n\n        for (var bidx in b_evt) {\n          b_evt[bidx][0](eff[eidx], eff[eidx].component(), b_evt[bidx][1]);\n        }\n      }\n      /* set transition */\n\n\n      effutl.transition(elst);\n\n      var next_order = function next_order() {\n        var fin_cnt = 0;\n        return function (p1, p2, p3) {\n          try {\n            var eff_cmp = elst[fin_cnt].component();\n            fin_cnt++;\n\n            if (p3 <= fin_cnt) {\n              if (false === effutl.exec(eff, eid, evf, oid + 1)) {\n                /* release transition */\n                cmputl.rstyle(eff_cmp, {\n                  'transition': null\n                }, {\n                  bpref: true\n                });\n                eff_cmp.styleDom().style({\n                  'transition': null\n                }, {\n                  bpref: true\n                });\n                /* execute callback function */\n\n                if (undefined !== evf && \"function\" === typeof evf[0]) {\n                  evf[0](p2, eid, evf[1]);\n                }\n              }\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n      };\n\n      var next = next_order(eff, eid, evf, oid);\n\n      for (var eidx2 in elst) {\n        elst[eidx2].otCallback(next, elst.length);\n\n        if (0 === elst[eidx2].speed()) {\n          elst[eidx2].execute();\n        } else {\n          setTimeout(function (tm) {\n            try {\n              tm.execute();\n            } catch (e) {\n              console.error(e.stack);\n              throw e;\n            }\n          }, 50, elst[eidx2]);\n        }\n      }\n\n      return true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n\n  /**\n   * get valid list from effect lists\n   */\n  getlist: function getlist(eff, eid, oid) {\n    try {\n      var elst = [];\n\n      for (var eidx in eff) {\n        if (true === eff[eidx].isSkipped(eid, oid)) {\n          continue;\n        }\n\n        elst.push(eff[eidx]);\n      }\n\n      return elst;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  initlist: function initlist(cmp) {\n    try {\n      var ret = [];\n      var chd = cmp.child();\n\n      for (var cidx in chd) {\n        var chd_ret = effutl.initlist(chd[cidx]);\n\n        if (null !== chd_ret) {\n          for (var _cidx in chd_ret) {\n            ret.push(chd_ret[_cidx]);\n          }\n        }\n      }\n\n      var eff = cmputl.modconf(cmp, cmputl.IDX_EFFECT);\n      var oid = 0;\n      var buf = null;\n\n      while (true) {\n        buf = effutl.getlist(eff, true === cmp.visible() ? 0 : 1, oid);\n\n        if (0 === buf.length) {\n          break;\n        }\n\n        for (var bidx in buf) {\n          ret.push(buf[bidx]);\n        }\n\n        oid++;\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  transition: function transition(eff) {\n    try {\n      var rdom = eff[0].component().rootDom();\n      var cmp_trans = {}; //effutl.gettrans(rdom.style('tarnsition'));\n\n      /* get the effect transition that will be executed */\n\n      var eff_trans = {};\n\n      for (var eidx in eff) {\n        if (0 === eff[eidx].speed()) {\n          continue;\n        }\n\n        var tbuf = eff[eidx].transition();\n\n        for (var bidx in tbuf) {\n          eff_trans[tbuf[bidx]] = eff[eidx].speed() + 'ms ';\n\n          if (null === eff[eidx].cubicBezier()) {\n            eff_trans[tbuf[bidx]] += eff[eidx].timing();\n          } else {\n            var cubic = eff[eidx].cubicBezier();\n            eff_trans[tbuf[bidx]] += 'cubic-bezier(' + cubic[0] + ',' + cubic[1] + ',' + cubic[2] + ',' + cubic[3] + ')';\n          }\n\n          eff_trans[tbuf[bidx]] += ' ' + eff[eidx].delay() + 'ms';\n        }\n      }\n\n      if (0 === Object.keys(eff_trans).length) {\n        return;\n      }\n      /* set transition list to buff */\n\n\n      for (var tidx in eff_trans) {\n        cmp_trans[tidx] = eff_trans[tidx];\n      }\n\n      var setval = {\n        'transition': \"\"\n      };\n\n      for (var tidx2 in cmp_trans) {\n        setval.transition += tidx2 + \" \" + cmp_trans[tidx2] + \",\";\n      }\n\n      if (0 < setval.transition.length) {\n        setval.transition = setval.transition.substring(0, setval.transition.length - 1);\n      }\n\n      cmputl.rstyle(eff[0].component(), setval, {\n        bpref: true\n      });\n      eff[0].component().styleDom().style(setval, {\n        bpref: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getfirst: function getfirst(eff, eid, ord) {\n    try {\n      for (var eidx in eff) {\n        if (false === eff[eidx].isSkipped(eid, ord)) {\n          return parseInt(eidx);\n        }\n      }\n\n      return null;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getlast: function getlast(eff, eid, ord) {\n    try {\n      var tgt_lst = [];\n\n      for (var eidx in eff) {\n        if (eid !== eff[eidx].eid()) {\n          continue;\n        } else if ('number' === typeof ord && ord !== eff[eidx].order()) {\n          continue;\n        }\n\n        tgt_lst.push(eff[eidx]);\n      }\n\n      if (0 === tgt_lst.length) {\n        return null;\n      }\n\n      var last = tgt_lst[tgt_lst.length - 1];\n\n      for (var eidx2 in eff) {\n        if (eff[eidx2].id() === last.id()) {\n          return parseInt(eidx2);\n        }\n      }\n\n      return null;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  setconf: function setconf(cmp, einf, cnf) {\n    try {\n      var eff = cmp.effect(einf);\n\n      if (null === eff) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      eff = true !== Array.isArray(eff) ? [eff] : eff;\n\n      for (var eidx in eff) {\n        eff[eidx].config(cnf);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nvar effutl = mofron.util.effect;\nmodule.exports = mofron.util.effect;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/effect.js?")},"./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function("return this")();\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')}});